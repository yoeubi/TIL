# 프로토타입

- 공통으로 사용하는 속성과 메서드가 있다. 

- 객체를 만들떄마다 함수를 새로만들어서 넘기는 것은 낭비이다. 

- 비슷한 객체들이 공유하는 속성을 한 곳에 모아두는 것이 프로토타입이다.

- 객체간에 공유되어야 하는 속성과 메서드를 프로토타입이라는 기능을 통해서 어떤 객체에서 기능을 받아쓰고 싶은 프로토타입 객체를 지정해서 만들수 있다.

```js
const person1 = Object.create()
```

- 프로토타입 기능을 이용해 한 객체에서 다른 객체의 기능을 가져와 사용하는 것을 프로토타입 상속 이라고 한다. 

- 어떤 객체의 부모를 가져오거나 부모를 바꿔버릴 수 있다.

- 객체 리터럴을 통해 생성된 객체의 프로토타입에는 자동으로 `Object.prototype` 이 지정이 된다.

- 속성을 읽어올려고 할려면 객체의 속성만 확인하는게 아니라 프로토타입 객체의 속성까지 확인합니다. 

- 속성 접근자를 통해 어떤 객체의 속성을 확인할때 프로토타입 체인을 전부 확인한다.

- 부모의 속성을 읽어 올수 있으나 변경 할 수 없다.

- 자식 객체의 프로토타입 객체를 통해서 자식 타입을 변경할 수 없다.

# 생성자의 프로토타입 속성 

- 생성자를 통해 만들어낸 객체의 프로토타입에는 생성자의 prototype 속성에 저장되어 있는 객체가 자동으로 지정됩니다.

```js
function Person(name) {
    this.name = name;
}
const person1 = new Person('승하')
Person.prototype.familyName = '김';
Person.prototype.introduce = function(){
    console.log(`안녕하세요 ${this.familyName}${this.name}입니다.`)
}
```

- 인스턴스의 부모는 생성자의 프로토타입이다.

- `this`의 결정방식 호출되는 시점에 결정된다. 

- `function` 함수로 만들어진 메소드 내부 `this`는 호출되는 시점에 결정이 된다.

- `this`는 호출하는 순간에 결정이 된다.

- 화살표 함수는 정의된 순간에 정의가 된다.

- 생성자의 인스턴스가 생성이 되면 생성자의 부모가 생기는데 그것이 생성자의 프로토타입이 된다.

# constructor

prototype은 빈 객체가 아니다 그게 constructor 이다.

# 정적 메소드

- 여러개의 인스턴스를 쓰거나 생성자와 관계가 있으나 `this`과 관계가 없다면 그냥 함수에 넣는다.

- 생성자의 속성에 함수를 직접 할당하는 것을 정적 메소드 라고 한다.

## reduce

```js
function filter(arr, func) {
    return arr.reduce(function(acc , item){
        if(function(item)) {
            acc.push(item);
        }
        return acc; 
    } , [])
}
```

- `reduce` 메소드에 초기값 인수를 주지 않으면 첫번째 요소가 초기값을 지정이 된다. 

- 초기값을 주는 것이 좋다.

- 배열을 순회 할때 순회중인 배열을 편집해서는 안된다.
# 2일차

## 마크업 순서

1. 시안을 분석 해서 뼈대 작업한다.
1. Sementic태그로 작업을 한다.


**주의사항**

구조를 만들 때 웹접근성을 고려해서 만들어야 한다

### ARIA (Accessible Rich Internet Applications)

접근가능한 리치 인터넷 어플리케이션(ARIA, Accessible Rich Internet Applications)은 웹 콘텐츠와 웹 어플리케이션을 제작할 때 적용할 수 있는 장애인을 위한 접근성 향상 방법을 정의합니다.  ARIA를 사용함으로써 내비게이션 랜드마크, JavaScript 위젯, 서식(form) 힌트, 에러 메시지 그리고 실시간 콘텐츠 업데이트 등에 접근성을 부여할 수 있습니다.

role 속성을 사용하여 객체(article, alert, slider와 같은 것들)의 일반(general) 타입을 정의할 수 있습니다. 이 외에도 ARIA 속성을 추가로 사용하여 서식에 관한 설명이나 상태바(progressbar)의 현재 값을 제공하는 등 유용한 프로퍼티들을 제공할 수 있습니다.

- `role`을 부여 하면 된다.

ex) `role="banner"`,`role="navigation"`,`role="main"`,`role="contentinfo"`


## box model

![box-model](https://mdn.mozillademos.org/files/8685/boxmodel-(3).png)

이 사각형 박스 각각은 표준 박스 모델을 사용합니다.

이 모델은 요소에 의해 차지되는 공간의 내용을 설명합니다.

각 박스는 네 경계가 있습니다. margin, border , padding , content 경계가 있습니다.

- content 영역은 요소의 실제 내용을 포함하는 영역입니다.
    - CSS `box-sizing`이 default 값으로 설정된 경우 `width`, `height`로 content 크기를 제어합니다.

- padding 영역은 padding을 둘러싼 border까지 미칩니다. content 영역이 배경색, 또는 그 위에 설정된 이미지가 있을 때, 이는 padding까지 이어집니다. 이것이 padding을 content의 연장으로 생각할수 있는 이유입니다.

- border 영역은 padding 영역을 border를 포함하는 영역까지 확장합니다. 이 border 경계 안쪽 영역입니다.

- margin 영역은 border 영역을 이웃 요소와 구별하기 위해 쓰는 빈 영역으로 확장합니다.
    - margin collapsing 이 일어날때 margin 영역은 margin이 박스 간에 공유되기 때문이다.
    - margin은 투명한 영역이다. 그래서 병합 마진 컬랩싱이 발생한다. 그래서 같은 등간격으로 표현할 수 있다.

**주의사항**

- 인라인 요소의 경우 차지하는 공간의 양은 비록 border 및 padding 이 content 주위에 눈에 보이더라고 `line-height`속성에 의해 결정이 된다.

### `box-sizing`

- `border-box`는 모바일 사이트를 만들떄 유용하다.

- 만약 `content-box`상태에서 `width: 100%`인 상태에서 `margin`을 적용하면 넘친부분이 짤리거나 뛰어날수 있다. 그래서 `border-box`를 사용한다.

- `button`은 default 값이 `border-box`이다.

- 모든 `box-sizing`을 `border-box`로 바꾸는 것이 유리하다.


#### `content-box`

- 이 값은 CSS 표준에 의해 정의된 기본 스타일이다. `width`와 `height`속성은 오로지 content만 포함해서 측정된다 padding, border, margin 은 포함하지 않는다.

    - padding, border, margin 은 박스 외부에 존재한다. `.box{width:350px;}`인 요소에 `{border : 10px solid black;}`을 적용하면 결과적으로 브라우저에서 렌더링 되는 것은 `.box{width:370px;}`이다.

#### `border-box`

- `width`와 `height` 속성이 padding , border 를 포함하고 margin을 포함하지 않는다. 

    - padding , border는 박스 안에 존재한다. `.box{width:350px}` 인 요소에 `{border : 10px solid black;}`를 적용하면 결과적으로 브라우저에 렌더링되는 것은 `.box{width:350px;}`이다.


- - -

## FLEX

![flex-container](https://css-tricks.com/wp-content/uploads/2014/05/flex-container.svg)

![flex-items](https://css-tricks.com/wp-content/uploads/2014/05/flex-items.svg)

- flex할 아이템들의 부모 요소에 `display:flex`라고 정의한다.

```css
.container {
display: flex; /* or inline-flex */
}
```

- 오직 직계 자식 요소들만 flex item이 된다 자식 요소 안의 요소들은 포함되지 않는다.

- `height`는 부모의 `height`만큼 늘어난다. `width`는 content 만큼 가진다.

### `flex-direction`

![flex-direction](https://css-tricks.com/wp-content/uploads/2013/04/flex-direction2.svg)

- `flex-direction`의 값에 따라 메인축과 교차축이 결정된다.

```css
.container {
  flex-direction: row | row-reverse | column | column-reverse;
}
```

### `flex-wrap`

![flex-wrap](https://css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg)

- 기본으로는 flex item들이 한 라인에 정렬이 된다. 이것들을 감쌀수 있게 바꿀 수 있다.

```css
.container{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```

- `nowrap`(default) : 모든 아이템들이 한 라인에 있다

- `wrap` : flex item들이 다중 라인으로 감싸질 것이다 top에서 bottom으로 

- `wrap-reverse` :  flex item들이 다중 라인으로 감싸질 것이다. bottom에서 top으로 

### `flex-flow`

- `flex-direction` , `flex-wrap`의 속기형이다.

```css
flex-flow: <‘flex-direction’> || <‘flex-wrap’>
```

### `justify-content`

![justify-content](https://css-tricks.com/wp-content/uploads/2013/04/justify-content-2.svg)

```css
.container {
  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;
}
```

- 메인축 정렬이다

- `flex-start`(default) : flex item들이 start라인부터 시작한다.

- `flex-end` : end라인부터 시작한다.

- `center` : 가운데 정렬되어 있다.

- `space-between` : 첫번째 flex item은 start 라인 마지막 item은 end라인에 있다.

- `space-around` : item들을 동일한 공간으로 감싼다. 

- `space-evenly` : 두 item간의 같은 공간을 가진다.

### `align-items`

![align-item](https://css-tricks.com/wp-content/uploads/2014/05/align-items.svg)

```css
.container {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

- flex item들을 교차죽 정렬한것이다.

- `baseline` : item들이 baseline 정렬을 한다.

- `stretch`(default) : container의 높이만큼 늘인다.

### `align-content`

![align-content](https://css-tricks.com/wp-content/uploads/2013/04/align-content.svg)

```css
.container {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

- flex container의 라인 여러줄일때 사용한다.

### `align-self`

![align-self](https://css-tricks.com/wp-content/uploads/2014/05/align-self.svg)

```css
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

- flex item 하나만 정렬 할때 사용한다.

### `order`

![order](https://css-tricks.com/wp-content/uploads/2013/04/order-2.svg)

```css
.item {
  order: <integer>; /* default is 0 */
}
```

- `order` 속성은 flex item의 순서를 조정하는 속성이다.

- `order`의 default 값은 0이다. 0보다 작으면 맨 앞쪽으로 가고 0보다 크면 뒤로간다.

- 같은 0번이면 마크업한 순서대로 그려진다.

### `flex-grow`

![flex-grow](https://css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg)

```css
.item {
  order: <integer>; /* default is 0 */
}
```

- flex item이 확대가 되는 속성이다..

- `flex-grow : 1` 이면 flex item들이 동일한 크기를 가지게 된다.

- `flex-grow : 2` 이면 다른 flex item 보다 남은 공간을 2배 가지게 된다.

### `flex-shrink`

```css
.item {
  flex-shrink: <number>; /* default 1 */
}
```

- flex item이 축소되는 속성이다.

### `flex-basis`

```css
.item {
  flex-basis: <length> | auto; /* default auto */
}
```

- flex item 의 가로 크기를 결정하는 것이다.


- - -

float

플렉스와 차이 
컨테이너에 디스플레이에 했는데


폴롯트는 

아이템을 직접 처리해야 한다 .

마크업 순서대로 배치되는 건 노멀 플로우 라고 한다

이제 플로트 시킨다는 것은 노멀 플로우를 벗어나게 만드는 것이다.

부모 영역의 라인 박스 영역만큼 왼쪽으로 배치가 된다

부모 영역안에서 왼쪽에 배치가 된다.

1번은 화면에 떠 있는데 그 영역에 곂쳐 있는 것이다.

텍스는 어노니머스 

라인 박스는 부모의 영역이다 

플롯 라이트는 부모의 오른쪽으로 간다. 

플로트 되는 순간 가용할수 있는 박스의 영역에서 시작한다. 

하지만 글자를 밀었는데 공간이 부족하면 밑으로 공간이 길어난다.

만약 인라인텍스트만 옆으로 하는 것이다.

만약 그 공간보다 크다면 새로운 라인 박스를 생성하고 그 안에 들어간다 
그리고 그 빈공간은 죽은 공간이 된다.

부모의 높이가 auto 하면 자식의 높이 만큼 된다. 

클리어 는 블록 속성에만 적용이 가능하다 그리고 그만큼 마진으로 설정이 된다.

디비전은 브록

스판은 인라인을 묵을때 쓴다

인라인은 위드 속성을 줄수 없다.
인라인 상자의 위든느 컨텐츠 크기 만큼만 늘어난다.

형제레벨에 클리어 속성을 주면 

플로트 형제레벨을 만들어서 클리어 보스를 한다.

이러한 클래스 이름을 clearfix 라고 통용해서 쓰고 있다.

하지만 불필요한 구조가 생긴다 

비어있는 요소를 삽입해서 클리어 처리 하는 방법을 추천하지 ㅇ낳는다.

그때 그룹3번에 형제레벨을 줘서 클리어 레벨을 주면 되는데

가상선택자를 만든다.

비포 애프터 는 퍼스트 차일드 라시트 차일드 이다.
하지만 기본적으로 인라인 박스로 만들어진다.
그래서 기본적으로 클리어 속성이 안먹힌다.

클리어픽스 모듈을 만든다  .clearfix::after
그래서 플로트 되는 부모에 추가를 하면 된다.

삭제된것 

.clearfix {
    background-color: tomato;
    width: 50px;
    height: 0 !important;
    float: left;
    clear: both;
    /* 부모 의 요소가 인식이 된다. */
}

북마크 7번째 사이트에 들어가면 된다.

http://naradesign.net/wp/2008/05/27/144/

프로트에 프로트 시킨다 
이떄는 2중 플로트 시킬떄 쓴다 .

b1, b2, b3 -> b2, b1, b3 로 만들떄 쓴다.


> ::after는 자식으로 들어가는건가?
자식 태그로 들어간다

> 플렉스의 width , height 의 원리 ....
축이 이동했다고 이해하면 된다. 


- - - 

#HTML

컨텐츠 중심(논리적인 마크업)

## 논리적인 마크업

예) 

예전에는 테이블로 사용해서 구조를 잡았다.

테이블 구조는 논리성을 지키기가 어렵다 
위에서 아래로 왼쪽에서 오른쪽이다.
일련의 작업이 밑으로 내려가는게 아니라 아래에서 위로 내려가기 때문이다.

1. 로고 컨텐츠
1. 텍스트 링크가 같이 모여있는 것을 텍스트 링크 모음이라고 명시 할수 있다. 
1. 메뉴 링크

컴포넌트 단위로 나누어야한다

분석 -> 설계 단계를 밟아야한다.

어떤 순서로 마크업을 할지 골라야한다 .

로그를 먼저 마크업 
우리 서비스 로그인이 필요하다면 사용자 경험에 따라서 결정해야한다.

1. 로고
1. 텍스트링크 모음
1. 메뉴 
순서로 마크업을 한다

시멘틱은 의미를 잘 전달할수 게 만들어야 한다. 

로고는 브래딩 영역이다.

로고가 그래서 대제목을 담당한다 그래서 h1 태그로 마크업한다

텍스트링크는 a링크로 마크업을 한다.
하지만 모음 은 목록으로 마크업을 한다. ul ol dl 으로 한다 .
순서가 중요하지 않으면 ul 중요하면 ol 정보 전달할라면 dl 이다.

자식 요소로 li태그를 포함해야한다. 

메뉴는 nav태그를 쓴다. nav안에 ul 을 포함시켜야한다.


> 설계를 하면서 엑셀로 정리 해야하다 

## 네이밍을 해야한다.

공통적인 컴포넌트를 이름이 있어야한다.

구조도 

header.header 
    h1.logo
        a
            img
    ul.info
        li
            a(홈)
        li
            a(로그인)
    nav.navigation
        h2(메인 메뉴) .a11y-hidden , readable-hidden
        ul.menu
            li
                ul
                    li
            li
                ul
                    li


로그는 이미지 인지 텍스트 인지 정해야한다.     

aria-label로 div에 선언해주면된다 그러면웹접근성이 높아진다.

로고는 이미지로 마크업할것이다

nav 는 h태그가 있어야한다. 아웃라인 알고리즘에 영향을 받기 때문이다.


단순히 이동할거라면 링크를 넣어야한다. 

하지만 이동이 아니라면 링크를 넣어선 안된다. 

이미지가 아닌 데코레이션을 이용하면 해상도를 높히면 꺠지지 않는다.
그리고 유지보수가 간편하다.

하나의 컨텐츠에 하나만 담아야한다.

구두점이 있어야 끝어서 읽는다.


ul.info>li*>a[href="#"] 하면 된다.

nav는 주요 네비게이션이라서 문서 안에서 하나만 사용 쓰는게 권장한다.

nav.navigation
    h2.readable-hidden(메인 메뉴)
    ul.menu
        li.menu-item
            span.menu-item-text(HTML에 대해)
            ul.sub-menu
                li
                    a

li 에 색깔을 노랑으로 하면 상속이 된다.
상속이 될수 있어서 잘 판단해서 만들어야한다 . 
이번에는 상속되지않는 것을 고를 것이다.
그래서 텍스트 노드만 묶어줄 필요성이 생긴다.    
그래서 그것을 span으로 감싼다.

.m li
요 글래스 안ㄴ에 있는 모든 li를 뜻한다.
제일 좋은 방법은 핸들링할 것을 네이밍을 주면 된다.

.m > li 하면 직께 자손으로 할수 있지만
위험할수 있다. 
모듈로 쪼갤때 클래스 단위로 하는 것이 좋다.
요소로 정의하지 않는 것을 추천한다.

span에도 클래스를 부여할것이다.

포커스를 받는 대상은 a , area ,button , input ,  select ,  textarea

tab-index="0" 하면 포커스를 받을 수있다.
마크업한 순서대로 받으라는 것 

li는 포커스를 못받으나 tabidnex를 줘서 받을수 있게 한것이다.


배치할때 방법중에 하나를 결정해야 한다 플로트 플렉스 그리지

하위는 플로트 포지션 방식 으로 할수 있다.

모던 방식은 플렉스 는 그리드 방식을 쓸수 이싿.

로고 배치는 포지션 기법을 사용 할 것이다.

포지션은 스태틱이 기본값이다 스테이
위치는 마크업 순서로 결정이 된다.

스태틱
릴레이티브
앱솔루티
픽스드
스티키 : 릴러티브 픽스드를 조합한 방식

자기 원래 있단 자리를 기준으로 움직이는 것이다.

노멀 플로우는 유지 하면서 
자기 위치를 유지 한다 자기 원리 자리기ㅜㄴ에서 움직이낟..

앱솔루트는 

레이어 계체이다 그래서 노멀플로우로 인식하지 않는다

포지션 앱솔루트는 제자리에서 붕 떠 있는 것이다.

앱솔루트의 
레이어의 높이 너비를 정하지 않으면 컨텐츠 만큼 정해진다.
인라인 상자로 변했다고 착각할수 있다.

렐러티브도 떠 있는 객체 엡솔루트도 떠있는데

마크업 순서에 따라 나중의 것이 위로 올라간다. 
그래서 제트 인덱스로 조정을 한다.

렐러티브는 자기 위치

앱솔루트는 자기의 상위 위치로 정한다.

로고는 헤더를 기준으로 배치가 된다.
앱솔루트는 자기보다 상위이며 포지션 스태틱이 아닐때만 인식한다.

픽스드도 앱솔루트 랑 같다

렐러티브는 노멀 플로우를 유지한다.

헤더를 앱솔루트를 움직이기 위한 

가급적 공백없이 이미지를 잘라야한다.

픽스드는 뷰포트가 기준이다.

스티키

## 선택자 우선 순위

클래스가 2개라면 

선택자의 파워가 같을 경우 나중엥 선언한것으로 된다.

엘리먼트는 1점이다.
클래스는 10점이다.
아이디는 100점이다.
인라인 1000점

            id class el
p           0   0       1
.note
body p.box

임포턴트하면 된다.

클래스는 아이디를 못 이긴다.

각각의 계급이 있다 비슷한 체급에서 경쟁해야한다 무시할라면 임포턴트를 쓴다.



# 3.3 state

props는 부모 컴포넌트가 설정하며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있습니다. 

컴포넌트 내부에서 읽고 또 업데이트할 수 있는 값을 사용할려면 state를 써야 합니다.

이것은 언제나 기본 값을 미리 설정해야 사용할 수 있으며, this.setState() 메서드로만 값을 업데이트 해야합니다.

# 3.3.1 컴포넌트의 생성자 메서드 : constructor()

state 초기값은 컴포넌트의 생성자 메서드인 constructor 내부에서 설정합니다. 생성자 메서드는 컴포넌트를 새로 만들 때 실행됩니다.

```js
// MyComponent.js
import React , {Component} from 'react';
import PropTypes from 'prop-types';

class MyComponent extends Component {
    ...
    constructor(props){
        super(props);
    }
    render(){
        ...
    }
}
export default MyComponent;
```

우리가 만든 MyComponent는 리액트의 Component 클래스를 상속합니다. 따로 constructor 메서드를 만들어 주지 않으면 Component 클래스의 생성자 메서드를 그대로 사용합니다. 

직접 constructor 메서드를 작성하여 생성자 메서드에서 추가 작업을 하려면, 메서드 내부에서 부모 클래스인 Component의 constructor 메서드를 먼저 호출해야 합니다. 

이때 super 키워드를 사용합니다. 컴포넌트를 만들 때 props 값들을 사용하므로 props를 메서드의 파라미터로 전달합니다.

# 3.3.2 state 초기값 설정

constructor 메서드 안에서 state의 초기 값을 지정해 봅니다.

```js
// MyComponent.js 중 constructor 메서드
constructor(props){
    super(props);
    this.state = {
        number : 0
    }
}
```

state 에 number 값을 0으로 설정했습니다.

# 3.3.3 JSX 내부에서 state 렌더링

이제 number 값을 JSX 안에서 렌더링해 보겠습니다, 이 를 렌더링하는 방법은 props를 렌더링하는 방법과 비슷합니다.

```js
// MyComponent.js 중 render 메서드
render(){
    return (
        <div>
            <p>안녕하세요, 제 이름은 {this.props.name} 입니다.</p>
            <p>저는 {this.props.age}살 입니다.</p>
            <p>숫자 : {this.state.number}</p>
        </div>
    )
}
```

# 3.3.4 state 값 업데이트 : setState()

state 값을 업데이트할 때는 this.setState 메서드를 사용합니다.

```js
this.setState({
    수정할 필드 이름 : 값,
    수정할 또 다른 필드 이름 : 값
})
```

버튼을 하나 렌더링하고 이 버튼을 누를 때마다 number 값이 1씩 추가되도록 설정해 보겠습니다.

```js
// MyComponent.js 중 render 메서드
render(){
    return (
        <div>
            <p>안녕하세요, 제 이름은 {this.props.name} 입니다.</p>
            <p>저는 {this.props.age}살 입니다.</p>
            <p>숫자 : {this.state.number}</p>
            <button onClick={() => {
                this.setState({
                    number :  this.state.number + 1
                })
            }}>더하기</button>
        </div>
    )
}
```

this,setState 메서드를 실행하는 함수가 버튼을 누를 때 실행되도록 설정했습니다.

## ES6의 화살표 함수

화살표 함수는 ES6 문법에서 함수를 표현하는 새로운 방식입니다. 그렇다고 해서 기존 function을 이용한 함수 선언 방식을 아예 대체하지는 않습니다.

사용 용도가 조금 다릅니다. 이 문법은 주로 함수를 파라미터로 전달할 때 유용합니다.

```js
setTimeout(function(){
    console.log('hello world')
}, 1000)
setTimeout(() => {
    console.log('hello world')
}, 1000)

// 이 문법은 기존 function을 대체할 수 없는 것은 용도가 다르기 때문입니다. 우선 서로 가리치고 있는 this 값이 다릅니다.

function BlackDog(){
    this.name = '흰둥이';
    return {
        name : '검둥이',
        bark : function () {
            console.log(this.name + ': 멍멍!')
        }
    }
}
const blackDog = new BlackDog();
blackDog.bark(); // 검둥이: 멍멍

function WhiteDog(){
    this.name = '검둥이';
    return {
        name : '흰둥이',
        bark : () => {
            console.log(this.name + ': 멍멍!')
        }
    }
}
const whiteDog = new WhiteDog();
whiteDog.bark(); // 흰둥이: 멍멍

// 일반 함수는 자신이 종속된 객체를 this로 가리키며 , 화살표 함수는 자신이 종속된 인스턴스를 가리킵니다.

// 화살표 함수는 값을 연산하여 바로 반환해야 할때 사용하면 가독성이 높습니다.
function twice(value){
    return value * 2;
}
const triple = (value) => value * 3;

// 따로 {}를 열러 주지 않으면 연산한 값을 그대러 반환한다는 의미입니다.
```

# 3.3.5 state를 constructor에서 꺼내기

원래 초기 state를 constructor 메서드에서 정의해야 하지만, defaultProps 와 propTypes를 정의할 때 사용한 transfrom-class-properties 문법으로 constructor 바깥에서 정의할 수도 있습니다.

```js
// MyComponent.js
import React , {Component} from 'react';
import PropTypes from 'prop-types';

class MyComponent extends Component {
    static defaultProps = {
        name : '기본 이름'
    }
    static propTypes = {
        name : PropTypes.string,
        age : PropTypes.number.isRequired
    }
    state = {
        number : 0
    }
    render (){
        ...
    }
}
export default MyComponent;
```

# 3.3.6 state 값을 업데이트할 때 주의 사항

state 값을 업데이트 할때는 언제나 setState로만 업데이트해야 합니다. 예를 들어 다음은 잘못된 코드입니다.

```js
this.state.number = this.state.number + 1;
this.state.someArray.push(3);
this.state.someObject.value = 3;
```

setState 메서드가 하는 역활을 파리미터로 전달받은 필드를 업데이트한 후 컴포넌트가 리렌더링하도록 트리거하는 것입니다. 하지만 state에 직접 접근하여 값을 수정하면 컴포넌트를 자동으로 리렌더링하지 않습니다.

이때 this.forceUpdate 메서드를 호출하여 강제로 리렌더링을 시작할 수 있지만, 이 방식은 매우 비효율적이므로 웬만하면 사용을 피해야합니다.

배열이나 객체를 업데이트 할때는 배열이나 객체 사본을 만들고 그 사본에 값을 업데이트 한후 , 사본으로 값을 설정하는 방식으로 진행합니다.


# 4.2 예제로 이벤트 핸들링 익히기

# 4.2.1 컴포넌트 생성 및 불러오기

# 4.2.1.1 컴포넌트 생성

src 디렉토리 내부에 EventPractice.js 파일을 만드세요

```js
// EventPractice.js
import React , {Component} from 'react';

class EventPractice extends Component {
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
            </div>
        )
    }
}
```

# 4.2.1.2 App.js 에서 EventPractice 불러오기

App.js 파일을 열고 방금 만든 파일을 import로 불러온후 MyComponent 아래쪽에 렌더링하세요

```js
// App.js
import React , {Component} from 'react';
import EventPractice from './EventPractice';

class App extends Component {
    render(){
        return (
            <EventPractice />
        )
    }
}
export default App;
```

# 4.2.2 onChange 이벤트 핸들링

# 4.2.2.1 onChange 이벤트 설정

EventPractice 컴포넌트에 input 요소를 렌더링하는 코드와 해당 요소의 onChange 이벤트를 설정하는 코드를 작성합니다. 

```js
// EventPratice.js
import React , {Component} from 'react';

class EventPractice extends Component {
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input 
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하세요"
                    onChange={
                        (e) => {
                            console.log(e);
                        }
                    }
                />
            </div>
        )
    }
}
export default EventPractice;
```

```js
// EventPractice.js 의 onChange 설정 부분 다시 보기
onChange={
    (e) => {
        console.log(e)
    }
}
```

여기서 콘솔에 기록되는 e 객체는 SyntheticEvent로 웹 브라우저의 네이티브 이벤트를 감싸는 객체입니다.

네이티브 이벤트와 인터페이스가 같으므로 순수 자바스크립트에서 HTML 이벤트를 다룰 때와 똑같이 사용하면 됩니다.

예를 들어 onChange 이벤트가 발생할 때, 앞으로 변할 인풋 값인 e.target.value를 콘솔에 기록해 보겠습니다.

```js
// EventPractice.js 의 onChange 설정 부분 다시 보기
onChange={
    (e) => {
        console.log(e.target.value)
    }
}
```

# 4.2.2.2 state에 input 값 담기

생성자 메서드인 constructor에서 state 초기값을 설정하고, 이벤트 핸들링 함수 내부에서 this.setState 메서드를 호출하여 state를 업데이트 합니다.

그 다음 input 의 value 값을 state 에 있는 값으로 설정하세요

```js
// EventPractice.js
import React, {Component} from 'react';

class EventPractice extends Component {
    state = {
        message : ''
    }
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input 
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하세요"
                    value={this.state.message}
                    onChange={
                        (e) => {
                            this.setState({
                                message : e.target.value
                            })
                        }
                    }
                />
            </div>
        )
    }
}
export default EventPractice;
```

# 4.2.2.3 버튼을 누를 때 comment 값을 공백으로 설정

입력한 값이 state에 잘 들어갔는지, 그리고 인풋에서 그 값을 제대로 반영하는지 한번 검증해 보겠습니다.

input 요소 코드 아래쪽에 button을 하나 만들고, 클릭 이벤트를 발생하면 현재 comment 값을 메시지 박스로 띄운 후 comment 값을 공백으로 설정하겠습니다.

```js
// EventPractice.js
import React , {Component} from 'react';

class EventPractice extends Component {
    state = {
        message : ''
    }
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input 
                    type="text"
                    name="message"
                    placeholder="아무거나 입력하세요"
                    value={this.state.message}
                    onChange={
                        (e) => {
                            this.setState({
                                message : e.target.value
                            })
                        }
                    }
                />
                <button onClick={
                    () => {
                        alert(this.state.message);
                        this.setState({
                            message :''
                        })
                    }
                }>확인</button>
            </div>
        )
    }
}
export default EventPractice;
```

alert를 사용하여 현재 message 값을 화면에 표시하게 했습니다.

# 4.2.3 임의 메서드 만들기

이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다.

그렇기에 이벤트를 처리할 때 렌더링을 하는 동시에 함수를 만들어서 전달해 주었습니다.

이 방법 대신 함수를 미리 준비하여 전달하는 방법도 있습니다. 성능상으로는 차이가 거의 없지만, 가독성을 훨씬 높습니다.

앞서 onChange 와 onClick에 전달된 함수를 따로 빼내서 컴포넌트 임의 메서드로 만들겠습니다.

# 4.2.3.1 기본 방식

```js
// EventPractice.js
import React , {Component} from 'react';

class EventPracitce extends Component {
    state = {
        message : ''
    }
    constructor(props){
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.handleClick = this.handleClick.bind(this);
    }
    handleChange(e){
        this.setState({
            message: e.target.value
        })
    }
    handleClick(){
        alert(this.state.message);
        this.setState({
            message : ''
        })
    }
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력해보세요"
                    value={this.state.message}
                    onChange={this.handleChange}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        )
    }
}
export default EventPractice;
```

컴포넌트에 임의 메서드를 만들면 기본적으로 this에 접근할 수없습니다. 따라서 컴포넌트의 생성자 메서드 인 constructor에서 각 메서드를 this와 바인딩 해 주어야합니다. 

즉, 메서드에서 this를 사용할 수 있도록 메서드에 this를 묶어 주는 것, 이 작업을 하지 않으면 메서드에서 this를 부를때 undefined가 리턴됩니다.

# 4.2.3.2 Property Initializer Syntax를 사용한 메서드 작성

메서드 바인딩은 생성자 메서드에서 하는 것이 정석입니다. 

이 작업을 좀 더 간단하게 하는 방법이 있습니다. 바로 바벨의 transform-class-properties 문법을 사용하여 화살표 함수 형태로 메서드를 정의하는 것입니다.

```js
// EventPractice.js
import React , {Component} from 'react';

class EventPracitce extends Component {
    state = {
        message : ''
    }
    handleChange = (e) => {
        this.setState({
            message: e.target.value
        })
    }
    handleClick = () => {
        alert(this.state.message);
        this.setState({
            message : ''
        })
    }
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력해보세요"
                    value={this.state.message}
                    onChange={this.handleChange}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        )
    }
}
export default EventPractice;
```

# 4.2.4 input 여러 개를 핸들링

input 이 여러 개일때는 메서드를 여러 개를 만들면 된다. 하지만 더 쉽게 처리하는 방법이 있습니다.

e.target.name 값을 사용하면 됩니다. onChange 이벤트 핸들러에서 e.target.name은 해당 인풋의 name을 가리킵니다.

이 값을 사용하여 state를 설정하면 쉽게 해결할 수 있습니다.

```js
// EventPractice.js
import React , {Component} from 'react';

class EventPractice extends Component {
    state = {
        message : '',
        username : ''
    }
    handleChange = (e) => {
        this.setState({
            [e.target.name] : e.target.value
        })
    }
    handleClick = () => {
        alert(this.state.username + ': ' + this.state.message);
        this.setState({
            username : '';
            message : '';
        })
    }
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input
                    type="text"
                    name="username"
                    placeholder="유저명"
                    value={this.state.username}
                    onChange={this.handleChange}
                />
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력해보세요"
                    value={this.state.message}
                    onChange={this.handleChange}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        )
    }
}
export default EventPractice;
```

다음 코드가 핵심입니다.

```js
this.setState({
    [e.target.name] : e.target.value
})
```

[] 안에 있는 값을 key 값으로 사용하는 것입니다.

# 4.2.5 onKeyPress 이벤트 핸들링

이번에는 키를 눌렀을때 발생하는 keyPress 이벤트를 처리하는 방법을 알아보겠습니다.

comment 인풋에서 enter를 눌렀을때 handleClick 메서드를 호출하도록 코드를 작성해 봅니다.

```js
// EventPractice.js
import React , {Component} from 'react';

class EventPractice extends Component {
    state = {
        username : '',
        password : ''
    }
    handleChange = (e) => {
        this.setState({
            [e.target.name] : e.target.value
        })
    }
    handleClick = () => {
        alert(this.state.username + ': ' + this.state.message);
        this.setState({
            username : '',
            message : ''
        })
    }
    handleKeyPress = (e) => {
        if(e.key === 'Enter'){
            this.handleClick();
        }
    }
    render(){
        return (
            <div>
                <h1>이벤트 연습</h1>
                <input
                    type="text"
                    name="username"
                    placeholder="유저명"
                    value={this.state.username}
                    onChange={this.handleChange}
                />
                <input
                    type="text"
                    name="message"
                    placeholder="아무거나 입력해보세요"
                    value={this.state.message}
                    onChange={this.handleChange}
                    onKeyPress={this.handleKeyPress}
                />
                <button onClick={this.handleClick}>확인</button>
            </div>
        )
    }
}
export default EventPractice;
```

# 4.3 정리 

리액트에서 이벤트를 다르는 것과 순수 자바스크립트 또는 jQuery를 사용한 웹 애플리케이션에서 이벤트를 다루는 것과 비슷합니다.


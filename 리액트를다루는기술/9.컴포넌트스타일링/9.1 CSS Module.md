가장 기본적인 방식은 CSS 파일을 사용하는 것입니다. 

```css
/* App.css */
.App {
    text-align : center;
}
.App-logo {
    animation : App-logo-spin infinite 20s linear;
    height : 80px;
}
.App-header {
    background-color : #222;
    height : 150px;
    padding : 20px;
    color : white;
}
.App-intro {
    font-size : large;
}
@keyframes App-logo-spin {
    from {transform: rotate(0deg)}
    to {transform : rotaote(360deg)}
}
```

```js
// App.js
import React , {Component} from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
    render(){
        return (
            <div className="App">
                <div className="App-header">
                    <img src={logo} className="App-logo" alt="logo"/>
                    <h2>Welcome to React</h2>
                </div>
                <p className="App-intro">
                    To get started, edit <code>src/App.js</code> and save to reload.
                </p>
            </div>
        )
    }
}
export default App;
```

webpack의 css-loader를 이용허여 일반 CSS를 불러오는 방식이 있습니다. CSS를 작성하다 보면 클래스네임이 중복될 가능성이 있는데, 이를 방지하려고 앞 코드에서는 각 클래스네임에 컴포넌트 이름을 접두사로 붙여 주었습니다. (예: App-header , App-intro 등)

접두사를 붙이는 방식 말고 다음 방식으로도 해결할 수 있습니다.

```css
.App {}
.App .header {}
.App .logo {}
.App .intro {}
```

CSS를 좀 더 쉽게 작성하려고 Sass, LESS , Stylus 등 CSS 전처리기를 사용하기도 합니다. Sass를 사용한다면 다음과 같이 작성할 수 있습니다.

```js
.App {
    .header {}
    .logo {}
    .intro {}
}
```

리액트 프로젝트에서 컴포넌트 스타일링을 할 때 자주 사용하는 방법입니다.
    - CSS Module : 모듈화 된 CSS로 CSS 클래스를 만들면 자동으로 고유한 클래스네임을 생성하여 스코프를 지역적으로 제한하는 방식입니다.
    - Sass : 자주 사용하는 CSS 전처리기 중 하나이며, 확장된 CSS 문법을 사용하여 CSS 코드를 더욱 쉽게 작성하는 방식입니다. 추가로 이를 CSS Module처럼 사용하는 방법도 있습니다.
    - styled-components : 요즘 인기 있는 컴포넌트 스타일링 방식으로, JS 코드 내부에서 스타일을 정의합니다.

# 9.1 CSS Module

CSS Module은 CSS를 모듈화하여 사용하는 방식입니다. CSS 클래스를 만들면 자동으로 고유한 클래스네임을 생성하여 스코프를 지역적으로 제한합니다. 

모듈화된 CSS를 webpack으로 불러온다면 다음과 같이 사용자가 정의한 클래스네임과 고유화된 클래스네임으로 구성된 객체를 반환합니다.

```
{
    box : 'src-App__box--mjrNr'
}
```

그리고 클래스를 적용할 때는 className= {styles.box} 방식으로 사용합니다.

# 9.1.1 CSS Moduel 활성화

CSS를 불러오는 과정에서 총 세 가지 로더를 사용했습니다. style-loader는 스타일을 불러와 웹 페이지에서 활성화하는 역활을 하고, css-loader는 css 파일에서 import 와 url() 문을 webpack의 require 기능으로 처리하는 역활을 합니다. 

postcss-loader는 모든 웹 브라우저에서 입력한 CSS 구문이 제대로 작동할 수 있도록 자동으로 -webkit, -mos , -ms 등 접두사를 붙여 줍니다.

css-loader에서 options의 첫 번째 설정 modules 는 CSS Module을 활성화합니다. 두 번째 속성 localIdentName은 CSS Module에서 고유하게 생성되는 클래스네임 형식을 결정합니다.

webpack.config.dev.js는 개발할때 가동하는 webpack 개발 서버 전용입니다. 나중에 배포할 때는 webpack.config.prod.js 파일도 변경해야합니다.

# 9.1.2 CSS Module 사용

```css
/* src/App.module.css */
.box {
    display : inline-block;
    width : 100px;
    height : 100px;
    border : 1px solid black;
    position : fixed;
    top : 50%;
    left : 50%;
    transform : translate(-50% ,-50%);
}
```

```js
// src/App.js
import React , {Component} from 'react';
import styles from './App.module.css';

class App extends Component {
    render(){
        return (
            <div className={styles.box}>
            
            </div>
        )
    }
}
export default App;
```

styles를 console.log를 하면

```js
Object {box : "src-App__pbx--mjrNr" }
```

클래스네임이 고유하게 설정이되어 있어서 CSS 클래스가 중복되어 충돌이 일어날수 없습니다.

# 9.1.2.1 클래스가 여러개 일때

style.box 도 문자열 형태의 값이기 때문에 사이에 공백을 두고 합치면 됩니다.

```css
/* src/App.module.css */
.box {
    display : inline-block;
    width : 100px;
    height : 100px;
    border : 1px solid black;
    position : fixed;
    top : 50%;
    left : 50%;
    transform : translate(-50% ,-50%);
}
.blue {
    background : blue;
}
```

```js
// src/App.js
import React , {Component} from 'react';
import styles from './App.module.css';

class App extends Component {
    render(){
        return (
            <div className={[styles.box , styles.blue].join(' ')}>
            </div>
        )
    }
}
export default App;
```

더 편한 방법은 classnames 라이브러리를 사용하는 것입니다.

```bash
yarn add classnames
```

```js
// src/App.js
import React , {Component} from 'react';
import classNames from 'classnames';
import styles from './App.module.css';

class App extends Component {
    render(){
        return (
            <div className={classNames(styles.box , styles.blue)}>
            </div>
        )
    }
}
export default App;
```

classNames(클래스이름 , 또 다른 클래스 이름) 방식으로 호출하면 잗오으로 사이에 공백을 넣어줍니다.

classNames의 bind 기능을 사용하면 좀 더 편합니다. 클래스네임을 입력할때 styles.을 생략할 수 있습니다.

```js
import React , {Component} from 'react';
import classNames from 'classnames/bind';
import styles from './App.module.css';

const cx = classNames.bind(styles);

class App extends Component {
    render(){
        return (
            <div className={cx('box' , 'blue')}>
            </div>
        )
    }
}
export default App;
```

classNames가 편한 이유는 여러 가지 형식으로 사용할 수 있습니다. 클래스 이름을 여러 파라미터로 나열했는데 이를 객체 형식이나 배열형식 또는 혼용해서 전달할 수 있습니다.

# 9.1.2.2 classNames 사용 예제

```js
classNames('foo','bar'); // 'foo bar'
classNames('foo', {bar : true }); // 'foo bar'
classNames({'foo-bar' : true }); // 'foo-bar'
classNames({'foo-bar' : false }); // ''
classNames({foo : true} , {bar : true}); // 'foo bar'
classNames({foo : true , bar : true}); // 'foo bar'
classNames(['foo','bar']); // 'foo bar'

// 형식을 동시에 여러 개 받아 올 수 있습니다.
classNames('foo',{bar : true , duck : false}, 'baz', {quuz : true}) // 'foo bar baz quuz'

// false, null , 0 , undefined는 무시됩니다.
classNames(null, false, 'bar', undefined , 0 ,1 , {baz : null}) // 'bar 1'
```

객체 형식으로 사용한다면 조건부 스타일링 할때 매우 편리합니다.

다음 코드에서는 isBlue 값이 true일때만 blue 클래스를 적용합니다.

```js
// src/App.js
import React , {Component} from 'react';
import classNames from 'classnames/bind';
import styles from './App.module.css';

const cx = classNames.bind(styles);

class App extends Component {
    render(){
        const isBlue = true;
        return (
            <div className={cx('box', {blue : isBlue})}>
            
            </div>
        )
    }
}
export default App;
```

이 값을 props로 받아 사용하면 손쉽게 props에 따라 동적인 스타일을 줄 수 있습니다.

CSS Module은 고유한 클래스네임을 만들어 스코프를 제한합니다. classnames 라이브러리는 사용하면 이를 더욱 편하게 할 수 있습니다.


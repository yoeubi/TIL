# 10.3 상태 관리

개발을 할때 상태 관리는 주로 기능별로 상태가 필요한 컴포넌트들을 감싸는 상위 컴포넌트에서  하는 것이 더 편리합니다.

## 좋지 않은 예

데이터 배열의 상태를 TodoList 컴포넌트에서 정의하고 TodoInput의 상태를 그 내부에서 정의한다면 이 경우 새 데이터를 TodoList에 넣으려면 비효율적인 방법을 사용할 수 밖에 없습니다.

1. TodoList 컴포넌트에 데이터 생성 메서드 만들기
1. App에서 TodoList에 ref 달기
1. TodoInput에 ref가 달린 TodoList의 데이터 생성 메서드를 props로 전달하기
1. TodoInput의 상태를 전달받은 함수에 파라미터로 넣기

## 좋은 예

데이터가 필요한 컴포넌트들의 상위 컴포넌트인 APpp에서 하는 것이 좋습니다. App의 state에서 input 값과 데이터 배열을 정의하고, 이를 변화시키는 메서드들도 정의하고 state 값과 메서드를 props로 하위 컴포넌트에 전달해서 사용하는 것이 바람직한 흐름입니다.

# 10.3.1 텍스트 입력 관련 상태 관리

TodoInput 컴포넌트가 사용할 input 상태부터 관리합니다. App.js 파일의 state에 input 값을 정의하고, 이 input의 변경 이벤트를 처리할 handleChange 메서드를 만들고 , 이것들을 TodoInput 컴포넌트의 props로 전달합니다.

```js
// src/components/App.js
import React , {Component} from 'react';
import PageTemplate from './PageTemplate';
import TodoInput from './TodoInput';
import TodoList from './TodoList';

class App extends Component {
    state = {
        input : ''
    }
    handleChange = e => {
        const {value} = e.target;
        this.setState({
            input : value
        })
    }
    render(){
        const {input} = this.state;
        const {
            handleChange
        } = this;
        return (
            <PageTemplate>
                <TodoInput onChange={handleChange} value={input}/>
                <TodoList/>
            </PageTemplate>
        )
    }
}
export default App;
```

render 함수에서 state와 메서드를 사용할 때도 비구조화 할당을 이용하여 레퍼런스를 미리 만들었습니다. 이렇게 하면 값을 사용할 때마다 this.props 또는 this를 참조하지 않아도 됩니다.

# 10.3.2 초기 일정 데이터 정의 및 렌더링

state에 todos라는 객체 배열을 만듭니다. 배열 안에는 기본값으로 두 객체를 넣습니다. 객체 안에는 id, text, done 값이 들어 있습니다. 

id 값은 각 데이터에 고유값을 부여하여 나중에 컴포넌트로 구성된 배열을 렌더링할 때 key로 사용합니다. 데이터를 변경할 때도 이값을 참조하여 데이터를 찾아 변경합니다. text는 일정 정보고, done은 체크 여부를 나타냅니다.

todos를 정의한 후 이 값을 TodoList의 props로 전달합니다.

```js
// src/components/App.js
import React , {Component} from 'react';
import PageTemplate from './PageTemplate';
import TodoInput from './TodoInput';
import TodoList from './TodoList';

class App extends Component {
    state = {
        input : '',
        todos : [
            { id: 0, text:'리액트 공부하기' , done : true},
            { id: 1, text:'컴포넌트 스타일링 공부하기', done:false}
        ]
    }
    handleChange = e => {
        const {value} = e.target;
        this.setState({
            input : value
        })
    }
    render(){
        const {input, todos} = this.state;
        const {
            handleChange
        } = this;
        return (
            <PageTemplate>
                <TodoInput onChange={handleChange} value={input}/>
                <TodoList todos={todos}/>
            </PageTemplate>
        )
    }
}
export default App;
```

TodoList 컴포넌트를 열고 todos 배열을 map 함수를 사용하여 TodoItem으로 구성된 컴포넌트 배열을 변환합니다.

```js
// src/components/TodoList/TodoList.js
import React ,{Component} from 'react';
import TodoItem from '../TodoItem';

class TodoList extends Component {
    render(){
        const {todos} = this.props;
        const todoList = todos.map(
            todo => (
                <TodoItem
                    key={todo.id}
                    done={todo.done}
                >
                    {todo.text}
                </TodoItem>
            )
        );
        return (
            <div>
                {todoList}
            </div>
        )
    }
}
export default TodoList;
```

# 10.3.3 데이터 추가하기

App 컴포넌트에 handleInsert 메서드를 정의합니다. 이 메서드는 새 데이터 객체를 만든 후 setState를 사용하여 todos 안에 넣어 줍니다.

객체 내부의 id값은 추가할 때 마다 1씩 더해집니다. 이때 사용할 id 값은 렌더링되는 정보가 아니므로 굳이 state 내부에 넣을 필요 없이 컴포넌트의 멤버 변수로 선언합니다. 

메서드를 만들면 input의 props로 전달합니다.

```js
// src/components/App.js
import React ,{Component} from 'react';
import PageTemplate from './PageTemplate';
import TodoInput from './TodoInput';
import TodoList from './TodoList';

class App extends Component {
    state = {
        input : '',
        todos : [
            {id:0,text:'리액트 공부하기',done:true},
            {id:1,text:'컴포넌트 스타일링 공부하기',done:false}
        ]
    }
    id = 1;
    getId = () => {
        return ++this.id;
    }
    handleChange = e => {
        const {value} = e.target;
        this.setState({
            input: value
        })
    }
    handleInsert = () => {
        const {todos, input} =this.state;
        const newTodo = {
            text : input,
            done : false,
            id : this.getId()
        }
        this.setState({
            todos: [...todos,newTodo],
            input:''
        })
    }
    render(){
        const {todos, input} = this.state;
        const {
            handleChange,
            handleInsert
        } = this;
        return (
            <PageTemplate>
                <TodoInput onChange={handleChange} value={input} onInser={handleInsert}/>
                <TodoList todos={todos}/>
            </PageTemplate>
        )
    }
}
export default App;
```

# 10.3.4 데이터 수정

데이터 수정은 TodoItem을 클릭했을때 체크박스를 활성화 하고 비활성화 하는 과정에서 일어납니다. 배열 안의 데이터를 수정하려면 id로 원하는 데이터를 찾아, slice와 전게 연산자를 사용해서 새 배열을 만드는 방식으로 업데이트 해야합니다. 

App 컴포넌트에서 handleToggle 메서드를 정의하여 이를 TodoList의 onToggle props로 전달합니다.

```js
// src/components/App.js
import React , {Component} from 'react';
import PageTemplate from './PageTemplate';
import TodoInput from './TodoInput';
import TodoList from './TodoList';

class App extends Component {

    ...
    handleToggle = id => {
        const {todos} = this.state.todos;
        const index = todos.findIndex(todo => todo.id === id);

        const toggled = {
            ...todos[index],
            done : !todos[index].done
        }
        this.setState({
            todos : [
                ...todos.slice(0, index),
                toggled,
                ...todos.slice(index + 1 , todos.length)
            ]
        })
    }
    render(){
        const {todos, input} = this.state;
        const {
            handleChange,
            handleInsert,
            handleToggle
        } = this;
        return (
            <PageTemplate>
                <TodoInput onChange={handleChange} onInsert={handleInsert} value={input}/>
                <TodoList todos={todos} onToggle={handleToggle}/>
            </PageTemplate>
        )
    }
}
export default App;
```

App 컴포넌트를 수정한 후에는 TodoList 컴포넌트도 수정해야합니다 props로 받은 onToggle 메서드를 실행할 때 index를 파라미터로 넣어 주어야 하기 때문입니다. 배열을 컴포넌트 배열로 변환하는 과정에서 onToggle 부분에서 화살표 함수 문법으로 새로운 함수를 선언합니다.

```js
// src/component/TodoList/TodoList.js
import React , {Component} from 'react';
import TodoItem from './TodoItem';

class TodoList extends Component {
    render(){
        const {todos , onToggle} = this.props;
        const todoList = todos.map(
            todo => (
                <TodoItem key={todo.id} done={todo.done} onToggle={() => onToggle(todo.id)}>
                    {todo.text}
                </TodoItem>
            )
        )
        return (
            <div>
                {todoList}
            </div>
        )
    }
}
export default TodoList;
```

# 10.3.5 데이터 제거

handleRemove 메서드를 정의해서 TodoList에 onRemove props로 전달합니다.

```js
// src/component/App.js
import React , {Component} from 'react';
import PageTemplate from './PageTemplate';
import TodoInput from './TodoInput';
import TodoList from './TodoList';

class App extends Component {
    handleRemove = id => {
        const {todos} = this.state;
        const index = todos.findIndex(todo => todo.id === id);

        this.setState({
            todos : [
                ...todos.slice(0,index),
                ...todos.slice(index + 1 , todos.length)
            ]
        })
    }
    render(){
        const {todos, input} = this.state
        const {
            handleChange,
            handleInsert,
            handleToggle,
            handleRemove 
        } = this;
        return (
            <PageTemplate>
                <TodoInput onInsert={handleInsert} onChange={handleChange} value={input}/>
                <TodoList todos={todos} onToggle={handleToggle} onRemove={handleRemove}/>
            </PageTemplate>
        )
    }
}
```

onRemove를 설정할때 화살표 함수로 새 함수를 만들고, todo.id를 파라미터로 전달합니다.

```js
// src/components/TodoList/TodoList.js
import React , {Component} from 'react';
import TodoItem from './TodoItem';

class TodoList extends Component {
    render(){
        const {todos, onToggle, onRemove} =this.props;
        const todoList = todos.map(
            todo => (
                <TodoItem key={todo.id} onToggle={() => onToggle(todo.id)} onRemove={() => onRemove(todo.id)}>
                    {todo.text}
                </TodoItem>
            )
        );
        return (
            <div>
                {todoList}
            </div>
        )    
    }
}
export default TodoList;
```

지우기 버튼의 상위 요소에는 클릭 이벤트에 onToggle이 설정되어 있기 때문에, 버튼을 누르면 onRemove -> onToggle 순으로 setState가 동시에 일어나면서 업데이트가 병합하여 데이터가 제대로 제거되지 않습니다.

자식 요소에도 onClick 이벤트로 설정되어 있고, 부모 요소에도 onClick 이벤트가 설정되어 있으면 자식 -> 부모 순으로 메서드를 실행하는데 이를 propagation이라고 합니다.

이를 방지하려면 자식 요소의 onClick 처리 함수 내부에서 e.stopPropagation 이라고 합니다.

```js
// src/components/TodoItem/TodoItem.js
import React , {Component} from 'react';
import styles from './TodoItem.scss';
import classNames from 'classnames/bind';

const cx = className.bind(styles);

class TodoItem extends Component {
    render(){
        const {done, children, onToggle, onRemove} = this.props;
        return (
            <div className={cx('todo-item')} onClick={onToggle}>
                <input className={cx('tick')} type="checkbox" checked={done} readOnly/>
                <div className={cx('text', {done})}>{children}</div>
                <div className={cx('delete')} onClick={ e => {
                    e.stopPropagation();
                    onRemove();
                }}>[지우기]</div>
            </div>
        )
    }
}
```

# 10.4 정리 

만든 프로젝트가 소규모이기 때문에 컴포넌트 리렌더링 최적화 작업을 따로 하지 않아도 정상적으로 동작합니다. 

하지만 규모가 크면 리렌더링을 할 때 조금씩 버퍼링이 발생할 수 있습니다.

클라이언트 쪽 자원을 더욱 효율적으로 사용하려면 불필요한 업데이트를 방지해야 합니다.
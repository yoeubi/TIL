# 12.2 리덕스 사용

리덕스는 리액트에서 사용하려고 만든 상태 관리 라이브러리이지만, 리액트에 의존하지는 않습니다.

즉 ,리액트를 사용하지 않아도 리덕스를 사용할 수 있습니다.

# 12.2.1 JSBin 준비

JSBin으로 리덕스를 사용해봅니다.

우선 CDN을 이용하여 JSBin에서 리덕스를 불러오겠습니다. Body안에 리덕스 CDN주소를 넣습니다.

파일을 불러오면 JavaScript 영역에서 리덕스를 사용할 수 있습니다. 

위쪽 HTML과 Output 영역은 비활성화하고 Javascript와 Console 영역만 활성화하세요.

실습하기전에 먼저 리덕스가 잘 불렀는지 console.log(Redux)를 입력하고 오른쪽 Run버튼을 누릅니다.

# 12.2.2 액션과 액션 생성 함수

액션은 스토어에서 상태 변화를 일으킬 때 참조한느 객체입니다. 이 객체는 type 값을 반드시 가지고 있어야 합니다. 

액션 타입은 해당 액션이 어떤 작업을 하는 액션인지 정의하며, 대문자와 밑줄을 조합하여 만듭니다.

```js
{
    type : 'INCREMENT'
}
```

이 액션은 상태에 있는 값의 수치를 올립니다. 이 값을 어떻게 업데이트할지는 나중에 리듀서라는 함수에서 정의합니다.

액션 객체안에서 type 값은 필수고, 나머지는 선택입니다. 즉, 있어도 되고 없어도 되고 형식도 자유입니다.

예를 들어 일정 관리 애플리케이션에서 새 일정을 만드는 액션은 어떤 형식으로 생성했는지 살펴보면

```js
{
    type :'INSERT_TODO',
    text : '리액트 배우기'
}
// 또는 다음과 같이 객체 형태로 넣을 수도 있습니다.
{
    type : 'INSERT_TODO',
    todo : {
        id : 1,
        text : '리액트 배우기',
        done : false
    }
}
```

액션에서 type 값은 고정이지만 나머지 값들은 유동적입니다. 액션을 새로 만들 때마다 직접 객체를 만들어 준다면 액션 형식을 모두 꿰고 있어야 하므로 불편합니다.

그래서 보통 액션을 만들어 주는 함수를 사용합니다. 이를 액션 생성 함수라고 합니다.

액션 생성 함수를 정의하려면 우선 액션 타입을 상수 값으로 정의해야합니다. 

숫자의 값을 더하고 빼는 카운트를 만든다면 INCREMENT 와 DECREMENT 액션을 만듭니다.

```js
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';
// INCREMENT는 값을 더하는 액션이고 DECREMENT는 값을 빼는 액션입니다.
// 이에 맞추어 액션 생성 함수도 만듭니다.
const increment = () => ({
    type : INCREMENT
})
const decrement = () => ({
    type : DECREMENT
})
```

액션 객체에 type 이외의 값이 없다면 위와 같이 정의하면 됩니다. 하지만 유동적인 값이 들어가야한다면 다음과 같이 파라미터를 넣어서 액션을 만듭니다.

```js
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

const increment = (diff) => ({
    type : INCREMENT,
    diff : diff
})
const decrement = (diff) => ({
    type : DECREMENT,
    diff : diff
})
```

액션을 제대로 만들었는지 콘솔에 기록해봅니다.

```js
console.log(increment(1));
console.log(decrement(1));
```

# 12.2.3 변화를 일으키는 함수, 리듀서

상태에 변화를 일으키는 함수인 리듀서를 알아보겠습니다. 리듀서는 파라미터를 두개 받습니다. 첫 번째 파라미터는 현재 상태고, 두번째 파라미터는 액션 객체입니다.

함수 내부에서는 switch문을 사용하여 action.type에 따라 새로운 상태를 만들어서 반환해야합니다.

리듀서가 초기에 사용할 초기 상태 initialState 값부터 먼저 설정해야 리듀서를 만들 수 있습니다. 

예제 코드에는 숫자 값이 필요하니 새 객체를 만들어서 그 안에 number라는 키를 0으로 설정하겠습니다.

액션 생성 함수 아래쪽에 initialState를 정의합니다.

```js
...
const initialState = {
    number : 0
}
// 이제 리듀서 함수를 만듭니다. 
function counter(state = initialState, action){
    switch(action.type){
        case "INCREMENT" : 
            return {number : state.number + action.diff};
        case "DECREMENT" : 
            return {number : state.number - action.diff};
        default : 
            return state;
    }
}
```

예제 코드가 숫자를 빼고 더하는 기능이라서 리듀서 함수의 이름이 counter로 지정하겠습니다.

함수에서 파라미터를 설정하는 부분에 state = initialState가 설정되어 있는데 이는 ES6문법으로 state 값이 undefined라면 initialState를 기본 값으로 사용한다는 의미입니다.

함수 내부에서는 action.type 에 따라 현재 상태와 액션 객체를 참조하여 새 객체를 만들어 주었습니다.

상태에 값이 하나만 있는 경우가 아니라면 다음과 같이 해야합니다.

```js
const initialState = {
    number : 1,
    foo : 'bar',
    baz : 'quz'
}
function counter(state = initialState , action){
    switch(action.type){
        case "INCREMENT" :
            return Object.assign({},state, {
                number : state.number + action.diff
            });
        case "DECREMENT" :
            return Object.assign({},state, {
                number : state.number - action.diff
            });
        default :
            return state;
    }
}
```

리덕스에서 상태를 업데이트할 때는 컴포넌트의 state를 다를 때 처럼 직접 수정하면 안되고 새로운 객체를 만든 후 그 안에 상태를 정의해야합니다.

Object.assign 함수를 실행하면 파라미터로 전달된 객체들을 순서대로 합쳐줍니다. 역순으로 객체를 왼쪽으로 덮어쓰면서 새 객체를 만들어 줍니다.

ES6문법의 전개 연산자를 사용하면 더욱 깔금하게 코드를 입력할 수 있습니다.

```js
function counter(state = initialState, action){
    switch(action.type){
        case "INCREMENT":
            return {
                ...state,
                number : state.number + actin.diff
            };
        case "DECREMENT":
            return {
                ...state,
                number : state.number - actin.diff
            };
        default :
            return state;
    }
}
```

리듀서를 잘 만들었는지 확인합니다.

```js
console.log(counter(undefined, increment(1)));
```

number 가 1에서 2로 변경되었습니다.

리덕스를 사용하면 이렇게 리듀서 함수를 직접 실행하는 일은 없습니다. 이 함수를 실행하는 작업은 리덕스 몫입니다.

# 12.2.4 리덕스 스토어 생성

액션과 리듀서가 준비되면 리덕스 스토어를 만들 수 있습니다.

```js
...
const {createStore} = Redux;
const stroe = createStore(counter);
```

스토어를 생성할 때는 createStore 함수를 사용합니다. 파라미터로는 리듀서 함수가 들어가고, 두번째 파라미터를 설정하면 해당 값을 스토어의 기본 값으로 사용합니다. 

이 파라미터를 생략하면 리듀서 초기값으로 스토어 기본 값으로 사용합니다.

# 12.2.5 구독

리액트 컴포넌트에서 리덕스 스토어를 구독하는 작업은 나중에 react-redux의 connect함수가 대신합니다. 따라서 리덕스의 내장 함수 subscribe를 직접적으로 사용할 일은 별로 없습니다.

리덕스 스토어를 구독한다는 것은 리덕스 스토어의 상태가 바뀔때마다 특정 함수를 실행시킨다는 의미입니다.

```js
...
const unsubscribe = store.subscribe(() => {
    console.log(store.getState());
})
```

스토어를 구독할 때는 subscribe 함수를 사용하는데 이 함수는 함수 형태의 파라미터를 받습니다. 파라미터로 전달된 함수는 스토어 상태에 변화가 일어날 때마다 호출됩니다. 

이 subscribe 함수가 호출되면 반환 값으로 구독을 취소하는 unsubscribe 함수를 반환합니다. 나중에 구독을 취소해야 할 때는 unsubscribe()를 입력하여 호출하면 됩니다.

getState 함수는 현재 스토어 상태를 반환합니다.

앞서 작성한 코드에는 스토어에 변화가 일어날 때마다 현재 상태를 읽어 와서 콘솔에 기록하도록 설정했는데 아무 액션도 디스패치를 하지 않았기에 콘솔에 아무것도 안나타난 것입니다.

# 12.2.6 dispatch로 액션 전달

스토어를 액션에 넣을 때는 store.dispatch 함수를 사용합니다.

```js
store.dispatch(increment(1));
store.dispatch(decrement(5));
store.dispathc(increment(10));
```

이 액션들이 디스패치 될때마다 구독할 때 등록한 함수를 실행합니다.


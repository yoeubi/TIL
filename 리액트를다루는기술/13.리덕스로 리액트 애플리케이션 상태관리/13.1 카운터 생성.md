상태 관리 라이브러리를 따로 사용하지 않고 state만 사용한다면 다음과 같은 문제점이 발생할 수 있습니다.

- 상태 객체가 너무 복잡하고 큽니다.
- 최상위 컴포넌트에서 상태 관리를 하는 메서드를 너무 많이 만들어 코드가 복잡합니다.
- 하위 컴포넌트에 props를 전달하려면 여러 컴포넌트를 거쳐야 합니다.

리덕스에서 함수를 스토어에 구독시킬 때 store.subscribe 함수를 사용 했습니다. store.getState 함수를 사용하여 상태를 가져왔습니다.

# 13.1 카운터 생성

# 13.1.1 작업 환경설정

# 13.1.1.1 create-react-app을 이용한 프로젝트 생성

```bash
create-react-app redux-counter
cd redux-counter
yarn add redux react-redux
```

# 13.1.1.2 프로젝트 초기화

src 디렉토리 안에 다음 파일을 삭제하세요

- App.css
- App.js
- App.test.js
- logo.svg

# 13.1.1.3 디렉토리 생성

src 디렉토리 내부에 다음 새 디렉토리들을 생성합니다.

- actions : 액션 타입과 액션 생성자 파일을 저장합니다.
- components : 컴포넌트의 뷰가 어떻게 생길지만 담당하는 프로젠테이셔녈 컴포넌트를 저장합니다.
- containers : 스토어에 있는 상태를 props로 받아 오는 컨테이너 컴포넌트들을 저장합니다.
- reducers : 스토어의 기본 상태 값과 상태의 업데이트를 담당하는 리듀서 파일들을 저장합니다.
- lib : 일부 컴포넌트에서 함께 사용되는 파일을 저장합니다. 

# 13.1.2 프로젠테이셔널 컴포넌트와 컨테이너 컴포넌트

프리젠테이셔녈 컴포넌트와 컨테이너 컴포넌트는 리덕스를 사용하는 프로젝트에서 자중 사용하는 구조입니다.

# 13.1.2.1 프리젠테이셔널 컴포넌트

프리젠테이셔녈 컴포넌트는 오직 뷰만 담당합니다. 안에 DOM 엘리먼트와 스타일이 있으며, 프리젠테이셔녈 컴포넌트나 컨테이너 컴포넌트가 있을 수도 있습니다.

하지만 리덕스 스토어에 직접 접근할 권한은 없으며, 오직 props로만 데이터를 가져올 수 있습니다. 또 대부분은 state가 없습니다. 있다고 해도 데이터와 관련된 것이 아니라 UI와 관련된 것이어야 합니다.

주로 함수형 컴포넌트로 작성하며, state가 있어야 하거나 최적화를 하려고 라이프사이클 메서드가 필요할 때는 클래스형 컴포넌트로 작성됩니다.

# 13.1.2.2 컨테이너 컴포넌트

이 컴포넌트는 프리젠테이셔널 컴포넌트들과 컨테이너 컴포넌트들의 관리를 담당합니다. 내부에 DOM 엘리먼트를 직접적으로 사용할 때는 없고, 감싸는 용도일 때만 사용합니다. 

또 스타일도 가지고 있지 않아야 합니다. 스타일은 모두 프리젠테이셔널 컴포넌트에서 정의해야 합니다. 상태를 가지고 있을 때가 많으며, 리덕스에 직접 접근할 수 있습니다.

# 13.1.2.3 이 구조의 장점

컴포넌트를 두 카테고리로 나누면 장점이 있습니다. 사용자가 이용할 유저 인터페이스와 상태를 다루는 데이터가 분리되어 프로젝트를 잉해하기 쉽고, 컴포넌트 재사용률도 높습니다.

# 13.1.2.4 오해

컨테이너 컴포넌트라고 해서 무조건 내부에 컴포넌트가 여러 개 있어야 하는 것은 아닙니다. 예를 들어 Item이란 프리젠테이셔널 컴포넌트가 있다면 ItemContainer라는 컨테이너 컴포넌트를 만들어서 그 안에 단일 Item만 넣고 데이터를 연결해도 됩니다.

또 프리젠테이셔널 컴포넌트 내부에 컨테이너 컴포넌트를 넣어도 됩니다. 예를 들어 템플릿 관련 프리젠테이셔널 컴포넌트를 만들고, 그 안에 여러 가지 컨테이너 컴포넌트들을 넣을 수 있습니다.   

# 13.1.3 기본적인 틀 생성

containers 디렉토리에 App 컴포넌트를 생성합니다.

```js
// src/container/App.js
import React , {Component} from 'react';

class App extends Component {
    render(){
        return (
            <div>
                Counter
            </div>
        )
    }
}
export default App;
```

이를 src/index.js 파일에 반영하세요.

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './containers/App';
import './index.css';

ReactDOM.render(
    <App/>,
    document.getElementById('root');
)
```

```bash
yarn start
```

# 13.1.4 Counter 컴포넌트 생성

프리젠테이셔널 컴포넌트인 카운터 컴포넌트를 만듭니다. 이 컴포넌트는 숫자와 색상 값, 더하기, 뺴기, 색상 변경 함수를 props로 전달 받습니다.

```js
// src/components/Counter.js
import React from 'react';
import PropTypes from 'prop-types';
import './Counter.css';

const Counter = ({number, color , onIncrement, onDecrement, onSetColor}) => {
    return (
        <div
            className="Counter"
            onClick={onIncrement}
            onContextMenu={ e => {
                e.preventDefault();
                onDecrement();
            }}
            onDoubleClick={onSetColor}
            style={{
                background : color
            }}>
            {number}
        </div>
    )
}

Counter.propTypes = {
    number : PropTypes.number,
    color : PropTypes.string,
    onIncrement : PropTypes.func,
    onDecrement : PropTypes.func,
    onSetColor : PropTypes.func
};

Counter.defaultProps = {
    number : 0,
    color : 'black',
    onIncrement : () => console.warn('onIncrement not defined'),
    onDecrement : () => console.warn('onIncrement not defined'),
    onSetColor : () => console.warn('onSetColor not defined')
}

export default Counter;
```

onContextMenu는 마우스 오른쪽 버튼을 눌렀을때 메뉴가 열리는 이벤트는 의미합니다. 이 함수가 실행될때 e.preventDefault 함수를 호출하면 메뉴가 열리는 것을 방지합니다.

컴포넌트 코드의 아래쪽에서는 props를 기본 값을 설정해 주었습니다. 

```css
/* src/components/Counter.css */
.Counter {
    /* 레이아웃 */
    width : 10rem;
    height : 10rem;
    display : flex;
    align-items : center;
    justify-content : center;
    margin : 1rem;
    /* 색상 */
    color : white;
    /* 폰트 */
    font-size: 3rem;
    /* 기타 */
    border-radius : 100%;
    cursor : pointer;
    user-select : none;
    transition : background-color 0.75s;
}
```

컴포넌트 모양은 동그라미, 숫자는 흰색으로 동그라미 가운데에 위치하도록 설정했습니다.

```js
// src/containers/App.js
import React , {Component} from 'react';
import Counter from './components/Counter';

class App extends Component {
    render(){
        return (
            <div>
                <Counter />
            </div>
        )
    }
};
```

# 13.1.5 액션 생성

모든 액션 객체에는 type 값이 필수로 있어야 합니다.

```js
{
    type : "INCREMENT"
}

{
    type : "DECREMENT"
}
// 액션과 함께 전달해야 할 값이 있을 때는 다음 과 같이 새로운 키를 추가해서 만들면 됩니다.
{
    type : "SET_COLOR",
    color : 'black'
}
```

type은 액션 이름과도 같습니다. 나중에 리듀서가 액션을 전달받으면 이 값에 따라서 해야 할 작업을 결정합니다. 그런데 이 값을 사용 할 때마다 직접 문자열을 입력해서 사용한다면 관리하기 어렵습니다. 이 값들을 따로 파일로 만들어서 저장하면 관리하기가 편합니다.

# 13.1.5.1 ActionTypes 관리

actions 디렉토리에 ActionTypes.js 라는 디렉토리를 만들어서 다음과 같이 상수를 선언합니다.

```js
// src/actions/ActionTypes.js
/* 
    Action 종류들을 선언합니다.
    앞에 export를 붙이면 나중에 이것들을 불러올 때,
    import * as types from './ActionTypes' 를 할 수 있습니다.
*/
export const INCREMENT = 'INCREMENT';
export const DECREMENT = 'DECREMENT';
export const SET_COLOR = 'SET_COLOR';
```

# 15.1.5.2 액션 생성 함수 만들기

액션을 만들 때마다 객체를 생성하기는 번거로우므로 액션을 만들어 내는 함수를 만들어 보내겠습니다.

actions 디렉토리에 index.js 파일을 생성합니다.

```js
// src/actions/index.js
/* 
    action 객체를 만드는 액션 생성 함수들을 선언합니다. 
*/
import * as types from './ActionTypes';

export const increment = () => ({
    type : types.INCREMENT
})
export const decrement = () => ({
    type : types.DECREMENT
})
export const setColor = (color) => ({
    type : types.SET_COLOR,
    color
})
```

increment와 decrement는 수치를 1씩 더하고 빼는 액션을 만들어 내므로 따로 필요한 것이 없습니다. 객체 내부에 type 값만 존재합니다.

하지만 setColor는 색상을 지정하는 액션이기 떄문에 파라미터로 color를 받고 이 값을 객체 안에 넣습니다.

# 13.1.6 리듀서 생성

리듀서는 액션의 type에 따라 변화를 일으키는 함수입니다. 이 리듀서를 작성할 때는 최초 변화를 일으키기 전 가지고 있어야 할 초기 상태를 정의해야합니다.

reducers 디렉토리에 index.js 파일을 생성하고 액션 타입들을 불러온 후 초기 상태를 선언합니다.

```js
// src/reducers/index.js
import * as types from '../actions/ActionTypes';

const initialState = {
    color : 'black',
    number : 0
}
```

이 리듀서의 초기 상태로는 color 값과 number 값이 있습니다. 리듀서 함수는 state 와 action을 파리미터로 가지는 함수며, 그 함수 내부에서 switch문으로 action.type에 따라 상태에 다른 변화를 일으킵니다.

state는 직접 수정하면 절대 안되고, 기본 state 값에 새 상태를 덮어쓴 상태 객체를 만드는 방식으로 처리해야 한다는 것입니다.

```js
// src/reducers/index.js
import * as types from '../actions/ActionTypes';

// 초기 상태를 정의합니다.
const initialState = {
    color : 'black',
    number : 0
}

/* 
    리듀서 함수를 정의합니다. 리듀서는 state와 action을 파리미터로 받습니다.
    state가 undefined일 때 (스토어가 생성될 때) state 기본 값을 initialState로 사용합니다.
    action.type에 따라 다른 작업을 하고 , 새 상태를 만들어서 반환합니다.
    이때 주의할 점은 state를 직접 수정해서는 안 되고, 기존 상태 값을 덮어쓴 새로운 객체를 만들어서 반환해야 합니다.
*/
function counter(state = initialState, action){
    switch(action.type){
        case types.INCREMENT :
            return {
                ...state,
                number : state.number + 1
            };
        case types.DECREMENT :
            return {
                ...state,
                number : state.number - 1
            };
        case types.SET_COLOR :
            return {
                ...state,
                color : action.color
            };
        default :
            return state;
    }
}
export default counter;
```

# 13.1.7 스토어 생성

스토어는 리덕스에서 가장 핵심적인 인스턴스입니다. 이 안에 현재 상태가 내장되어 있고, 상태를 업데이트할 때 마다 구독 중인 함수들을 호출합니다.

리액트에서 스토어를 생성할 때는 보통 프로젝트의 엔트리 포인트인 src/index.js 파일에서 만듭니다.

리덕스에서 createStore를 불러와 해당 함수에 리듀서를 파라미터로 넣어 스토어를 생성합니다.

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './containers/App';
import './index.css';

import {createStore} from 'redux';
import reducers from './reducers';

const store = createStore(reducers);

ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

# 13.1.8 Provider 컴포넌트로 리액트 앱에 store 연동

Provider는 react-redux 라이브러리에 내장된 리액트 애플리케이션에 손쉽게 스토어를 연동할 수 있도록 도와주는 컴포넌트입니다.

이 컴포넌트를 불러온 후 연동할 프로젝트의 최상위 컴포넌트를 감싸고 Provider 컴포넌트의 props로 store를 넣어 주면 됩니다.

```js
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './containers/App';
import './index.css';

import {createStore} from 'redux';
import reducers from './reducers';
import {Provider} from 'react-redux';

const store = createStore(reducers);

ReactDOM.render(
    <Provider store={store}>
        <App/>
    </Provider>,
    document.getElementById('root')
)
```

# 13.1.9 CounterContainer 컴포넌트 생성

컨테이너 컴포넌트에는 스토어가 연동되어 있습니다. react-redux 라이브러리의 connect 함수를 사용하여 컴포넌트를 스토어에 연결시킵니다.

connect 함수에는 파라미터가 세개 들어갑니다.

```
connect([mapStateToProps],[mapDispatchToProps],[mergeProps])
```

각 파리미터는 선택이므로 불필요하다면 생략해도 됩니다. 이 파라미터들은 함수 형태며,컴포넌트에서 사용할 props를 반환합니다.

- mapStateToProps : store.getState 결과 값인 state를 파라미터로 받아 컴포넌트의 props로 사용할 객체를 반환합니다.
- mapDispatchToProps : dispatch를 파라미터로 받아 액션을 디스패치하는 함수들을 객체안에 넣어서 반환합니다.
- mergeProps : state와 dispatch가 동시에 필요한 함수를 props로 전달해야 할 때 사용하는데, 일반적으로는 잘 사용하지 않습니다.

connect 함수를 호출하고 나면 또 다른 함수를 반환합니다. 이때 반환하는 함수의 파라미터로 리덕스를 연결시킬 컴포넌트를 넣으면 mapStateToProps와 mapDispatchProps에서 정의한 값들을 props로 받아 오는 새 컴포넌트를 만듭니다.

containers 디렉토리에 CounterContainer.js 파일을 생성합니다.

```js
// src/containers/CounterContainer.js
import Counter from '../components/Counter';
import * as actions from '../actions';
import {connect} from 'react-redux';

// 13가지 색상 중 랜덤으로 선택하는 함수입니다.
export function getRandomColor(){
    const colors = [
      '#495057',
      '#f03e3e',
      '#d6336c',
      '#ae3ec9',
      '#7048e8',
      '#4263eb',
      '#1c7cd6',
      '#1098ad',
      '#0ca678',
      '#37b24d',
      '#74b816',
      '#f59f00',
      '#f76707'
  ];
    // 0 부터 12까지 랜덤 숫자
    const random = Math.floor(Math.random() * 13);

    // 랜덤 색상 반환
    return colors[random];
}

/* store 안의 state 값을 props로 연결합니다. */
const mapStateToProps = (state) => ({
    color : state.color,
    number : state.number
})

/* 
    액션 생성 함수를 사용하여 액션을 생성하고,
    해당 액션을 dispatch하는 함수를 만든 후 이를 props로 연결합니다.
*/
const mapDispatchToProps = (dispatch) => ({
    onIncrement : () => dispatch(actions.increment()),
    onDecrement : () => dispatch(actions.decrement()),
    onSetColor : () => {
        const color = getRandomColor();
        dispatch(actions.setColor(color))
    }
})

// Counter 컴포넌트의 Container 컴포넌트
// Counter 컴포넌트의 애플리케이션의 데이터 레이어와 묶는 역활을 합니다.
const CounterContainer = connect(
    mapStateToProps, 
    mapDispatchToProps
)(Counter);

export default CounterContainer;
```

mapStateToProps의 color 값, number 값과 mapDispatchToProps의 onIncrement값, onDecrement 값, onSetColor 값이 Counter 컴포넌트의 props로 들어갑니다.

이렇게 리덕스와 연동된 컴포넌트를 CounterContainer 안에 담아 이를 내보낸 후 App 컴포넌트에서 Counter 대신 CounterContainer 컴포넌트를 불러옵니다.

```js
// src/containers/App.js
import React , {Component} from 'react';
import CounterContainer from './CounterContainer';

class App extends Component {
    render(){
        return (
            <div>
                <CounterContainer/>
            </div>
        )
    }
}
export default App;
```

# 13.1.10 서브 리듀서 생성

기존에 만든 리듀서는 색상과 숫자를 한 객체 안에 넣어서 관리합니다.

이 리듀서를 서브 리듀서 두 개로 나누어 파일을 따로 분리시킨 후 combineReducers로 다시 합쳐 루트 리듀서로 만듭니다.

reducers 디렉토리에 color.js 와 number.js 파일을 만듭니다.

```js
// src/reducers/color.js
import * as types from '../actions/ActionTypes';

const initialState = {
    color : 'black'
}
const color = (state = initialState , action) => {
    switch(acton.type){
        case types.SET_COLOR : 
            return {
                color : action.color
            };
        default :
            return state;
    }
}
export default color;
// src/reducers/number.js
import * as types from '../actions/ActionTypes';

const initialState = {
    number : 0
}
const number = (state= initialState, action) => {
    switch(action.type){
        case types.INCREMENT :
            return {
                number : state.number + 1
            };
        case types.DECREMENT :
            return {
                number : state.number - 1
            };
        default :
            return state;
    }
}
export default number;
```

기존에 한 파일로 작성했던 코드를 파일 두개로 분리시켰습니다. 이렇게 분리한 리듀서를 서브리듀서라고 합니다.

서브리듀서를 만든 후에는 이를 통합시키는 루트 리듀서를 만듭니다.

reducers 디렉터리에서 index.js 파일을 열어 기존 코드를 삭제합니다. 그리고 다음과 같이 color 와 number 리듀서를 불러옵니다. 

redux 라이브러리의 combineReducers 로 리듀서를 합쳐 주고 내보기를 합니다.

```js
// src/reducers/index.js
import color from './color';
import number from './number';

import {combineReducers} from 'redux';

/* 
    서브 리듀서를 하나로 합칩니다.
    combineReducers를 실행하고 나면 , 나중에 store 형태 
    파라미터로 전달한 객체 모양대로 만듭니다.
    지금은 다음과 같이 만듭니다.
    {
        numberData : {
            number : 0
        },
        colorDate : {
            color : 'black'
        }
    }
*/
const reducers = combineReducers({
    numberData : number,
    colorData : color
})
export default reducers;
```

combineReducers를 호출할 때는 객체를 파라미터로 전달하는데 이 객체 구조에 따라 합친 리듀서 상태 구조를 정의합니다.

CounterContainer 컴포넌트의 mapStateToProps를 수정합니다.

```js
// src/containers/CounterContainer.js
const mapStateToProps = (state) => ({
    color : state.colorDate.color,
    number : state.numberData.number
})
```
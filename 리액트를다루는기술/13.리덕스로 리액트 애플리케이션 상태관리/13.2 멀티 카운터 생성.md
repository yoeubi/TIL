# 13.2 멀티 카운터 생성

# 13.2.1 리덕스 개발자 도구 사용

리덕스에서 액션을 디스패치할 때마다 기록을 확인하고 이전의 상태로 돌아갈 수도 있게 하는 리덕스 개발자 도구를 알아보겠습니다.

# 13.2.1.1 확장 프로그램 설치

리덕스 개발자 도구를 사용하려면 크롬 웹 브라우저를 사용해야 합니다. 

크롬 웹 스토어에서 Redux DevTools를 검색하여 크롬에 추가합니다. 이 확장 프로그램을 설치하고 크롬 개발자 도구를 열면 Redux 탭이 나타납니다. 

하지만 설치한다고 해서 바로 사용할 수 있는 것은 아닙니다.

프로젝트에서 스토어를 생성할 때는 별도로 개발자 도구를 활성화 하는 작업을 해야 작동합니다.

# 13.2.1.2 프로젝트에서 개발자 도구 설정

src 디렉토리의 index.js 파일을 열어 스토어를 생성하는 코드를 다음과 같이 수정합니다

```js
// src/index.js

// 스토어 생성
const store = createStore(reducers, window.devToolExtension && window.devToolExtension());
```

이 도구를 사용하면 현재 리덕스 상태는 어떤지, 방금 디스패치한 액션은 무엇인지, 액션으로 어떤 값을 바꾸었는지 확인할 수 있습니다.

# 13.2.2 Actions 수정

# 13.2.2.1 액션 타입 수정

ActionTypes 파일 부터 수정합니다. 카운터를 추가하는 CREATE와 카운터를 제거하는 REMOVE를 액션 타입에 추가합니다.

```js
// src/actions/ActionTypes.js

/* 
    Action 종류들을 선언합니다.
    앞에 export를 붙이면 나중에 이것들을 불러올 때 
    import * as types from './ActionTypes';
*/
export const INCREMENT = 'INCREMENT';
export const DECREMENT = 'DECREMENT';
export const SET_COLOR = 'SET_COLOR';

export const CREATE = 'CREATE';
export const REMOVE = 'REMOVE';
```

# 13.2.2.2 액션 생성 함수 수정

기존 액션 생성 함수들도 앞으로 작동 방식이 달라지기 때문에 전체적으로 수정해야 합니다.

INCREMENT, DECREMENT ,SET_COLOR 액션이 특정 카운터를 조작할 수 있도록 설정해야 하므로 index 값을 액션 객체에 포함해야 합니다.

```js
// src/actions/index.js

import * as types from './ActionTypes';

export const create = (color) => ({
    type : types.CREATE,
    color
});
export const remove = () => ({
    type: types.REMOVE
});
export const increment = (index) => ({
    type : types.INCREMENT,
    index
})
export const decrement = (index) => ({
    type : types.INCREMENT,
    index
})
export const setColor = ({index,color}) => ({
    type : types.INCREMENT,
    index,
    color
})
```

create 함수는 카운터를 새로 만들 때 기본 색상을 받을 수 있도록 color가 파라미터로 설정되어 있고, remove 함수는 맨 마지막 카운터를 삭제하기 때문에 따로 index 값이 주어지지 않았습니다.

나머지 함수들은 어떤 카운터를 수정해야 할지 명시하려고 index 값을 파라미터로 받습니다.

예를 들어 increment(3)으로 만든 액션은 index가 3인 카운터 값을 1씩 올립니다.

# 13.2.3 Reducers 수정

이전에 만든 리듀서들과 작동 방식이 다르므로 reducers 디렉터리 안에 들어 있던 기존 color.js 와 number.js 파일을 삭제합니다. index.js 파일 내용도 비우고 새로 작성합니다.

# 13.2.3.1 초기 상태 정의

```js
// src/reducers/index.js
import * as types from '../actions/ActionTypes';

// 초기 상태를 정의합니다.
const initialState = {
    counters : [
        {
            color : 'black',
            number : 0
        }
    ]
}
```

상태 안에 counters 배열을 만들고 내부에는 color 값, number 값을 가진 객체를 만들어 넣습니다.

# 13.2.3.2 리듀서 함수에서 카운터 추가 및 삭제 구현

리듀서 함수를 다시 만들어 카운터를 추가하는 업데이트 로직과 제거하는 업데이트 로직을 구현하겠습니다.

```js
// src/reducers/index.js
...
function counter(state = initialState , action){
    const {counters} = state;
    switch(action.type){
        case types.CREATE : 
            return {
                counters : [
                    ...counters,
                    {
                        color : action.color,
                        number : 0
                    }
                ]
            };
        case types.REMOVE : 
            return {
                counters : counters.slice(0, counters.length - 1)
            };
        default :
            return state;
    }
}
export default counter;
```

배열을 업데이트 하는 것은 setState로 컴포넌트의 state 안에 있는 배열을 다룰 때와 동일합니다.

기존 배열에 push 또는 pop 배열 함수를 사용하여 값을 변경하면 안 되고, 전개 연산자를 사용하거나 slice 함수로 배열을 잘라서 새로 생성해야합니다.

이 과정에서 함수 위쪽에 counters의 레퍼런스를 만들면 자주 사용하는 state.counters 관련 코드양이 줄어들어 코드가 더 깔끔합니다.

# 13.2.3.3 리듀서 함수에 증가, 감소, 색상 변경 구현

INCREMENT, DECREMENT, SET_COLOR 에 대한 액션을 처리합니다. 

```js
// src/reducers/index.js
...
function counter(state = initialState , action){
    const {counters} = state;
    switch(action.type){
        ...
        case types.INCREMENT :
            return {
                counters : [
                    ...counters.slice(0,action.index),
                    {
                        ...counters[action.index],
                        number : counters[action.index].number + 1
                    },
                    ...counters.slice(index + 1 , counters.length)
                ]
            }
        case types.DECREMENT :
            return {
                counters : [
                    ...counters.slice(0,action.index),
                    {
                        ...counters[action.index],
                        number : counters[action.index].number - 1
                    },
                    ...counters.slice(index + 1 , counters.length)
                ]
            }
        case types.SET_COLOR :
            return {
                counters : [
                    ...counters.slice(0,action.index),
                    {
                        ...counters[action.index],
                        color : action.color
                    },
                    ...counters.slice(index + 1 , counters.length)
                ]
            };
        default :
            return state;
    }
}
export default counter;
```

# 13.2.4 프리젠테이셔널 컴포넌트 생성

카운터를 여러 개를 다룰 수 있도록 카운터 생성 및 제거를 담당하는 Buttons 컴포넌트와 카운터 여러 개를 렌더링할 CounterList를 만들어 보겠습니다.

# 13.2.4.1 생성 및 제거 버튼 - Buttons 컴포넌트 생성

이 컴포넌트는 버튼 2개를 내장하고 있으며 새 카운터를 생성하는 onCreate 함수 마지막 카운터를 제거할 onRemove 함수를 props로 전달받습니다.

```js
// src/components/Buttons.js
import React from 'react';
import PropTypes from 'prop-types';
import './Buttons.css';

const Buttons = ({onCreate, onRemove}) => {
    return (
        <div className="Buttons">
            <div className="btn add" onClick={onCreate}>생성</div>
            <div className="btn remove" onClick={onRemove}>제거</div>
        </div>
    )
}
Buttons.propTypes = {
    onCreate : PropTypes.func,
    onRemove : PropTypes.func
};
Buttons.defaultProps = {
    onCreate : () => console.warn('onCreate not defined'),
    onRemove : () => console.warn('onRemove not defined')
}
export default Buttons;
```

```css
.Buttons {
    display : flex;
}
.Buttons .btn {
    flex : 1;
    display : flex;
    align-items : center;
    justify-content : center;
    height : 3rem;

    color : white;
    font-size : 1.5rem;
    cursor : pointer;
}
.Buttons .add {
    background : #37b24d;
}
.Buttons .add:hover {
    background : #40c057;
}
.Buttons .remove{
    background : #f03e3e;
}
.Buttons .remove:hover {
    background : #fa5252;
}
```

# 13.2.4.2 여러 카운터를 렌더링 : CounterList 컴포넌트 생성

여러 카운터를 렌더링할 CounterList 컴포넌트를 만들겠습니다. 이 컴포넌트는 카운터 객체들의 배열 counters 와 카운터 값을 조작하는 onIncrement, onDecrement, onSetColor 함수를 props로 전달받습니다.

이 컴포넌트 내부에서 counters 배열을 Counter 컴포넌트의 배열로 map을 합니다. key는 배열의 index로 설정하고, index 값도 컴포넌트의 props로 전달해 줍니다.

그리고 color 값과 number 값을 일일이 설정하는 대신 {...counter}를 JSX 내부에 넣어주면 해당 값들이 풀어서 각 값을 한꺼번에 전달할 수 있습니다.

```js
// src/components/CounterList.js
import React from 'react';
import Counter from './Counter';
import PropTypes from 'prop-types';

import './CounterList.css';

const CounterList = ({counters, onIncrement , onDecrement, onSetColor}) => {
    const counterList = counters.map(
        (counter, i) => (
            <Counter
                key={i}
                index={i}
                {...counter}
                onIncrement={onIncrement}
                onDecrement={onDecrement}
                onSetColor={onSetColor}/>
        )
    )
    return (
        <div className="CounterList">
            {counterList}
        </div>
    )
}
CounterList.propTypes = {
    counters : PropTyps.arrayOf(PropTypes.shape({color: PropTypes.string, number: PropTypes.number})),
    onIncrement : PropTypes.func,
    onDecrement : PropTypes.func,
    onSetColor : PropTypes.func
}
CounterList.defaultProps = {
    counters : []
}
export default CounterList;
```

```css
/* src/components/CounterList.css */
.CounterList {
    margin-top : 2rem;
    display : flex;
    justify-content : center;
    flex-wrap : wrap;
}
```

# 13.2.4.3 Counter 컴포넌트 수정

CounterList에서 전달받은 index를 각 이벤트를 실행할 때 함수의 파라미터로 넣어서 실행 할 수 있게 합니다.

```js
// src/components/Counter.js
import React from 'react';
import PropTypes from 'prop-types';
import './Counter.css';

const Counter = ({number, color, index, onIncrement, onDecrement, onSetColor}) => {
    return (
        <div
            className="Counter"
            onClick={() => onIncrement(index)}
            onContextMenu={e => {
                e.preventDefault();
                onDecrement(index);
            }}
            onDoubleClick={() => onSetColor(index)}
            style={{
                background: color
            }}>
            {number}
        </div>
    )
}
Counter.propTypes = {
    index : PropTypes.number,
    number : PropTypes.number,
    color : PropTypes.string,
    onIncrement : PropTypes.func,
    onDecrement : PropTypes.func,
    onSetColor : PropTypes.func
}
Couneter.defaultProps = {
    index : 0,
    number : 0,
    color : 'black',
    onIncrement : () => console.warn('onIncrement not defined'),
    onDecrement : () => console.warn('onDecrement not defined'),
    onSetColor : () => console.warn('onSetColor not defined'),
}
export default Counter;
```

# 13.2.5 컨테이너 컴포넌트 

기존 컨테이너 컴포넌트인 CounterContainer는 제거합니다.

만들 컨테이너 컴포넌트는 CounterListContainer 입니다. Buttons는 따로 컨테이너 컴포넌트를 만들어 주지 않고 App 컴포넌트를 리덕스에 연결하여 액션 함수를 연결하고, 해당 함수들을 Buttons 컴포넌트에 전달하겠습니다.

# 13.2.5.1 CounterListContainer 컴포넌트 생성

mapStateToProps로 리덕스 스토어에 있는 props로 전달하고 mapDispatchToProps로 액션 생성 함수들을 연결합니다.

```js
// src/containers/CountetListContainer.js
import CounterList from '../components/CounterList';
import * as actions from '../actions';
import {connect} from 'react-redux';

export function getRandomColor(){
     const colors = [
      '#495057',
      '#f03e3e',
      '#d6336c',
      '#ae3ec9',
      '#7048e8',
      '#4263eb',
      '#1c7cd6',
      '#1098ad',
      '#0ca678',
      '#37b24d',
      '#74b816',
      '#f59f00',
      '#f76707'
  ];
  const random = Math.floor(Math.random() * 13);
  return colors[random];
}

// store 안에 있는 state를 props로 연결합니다.
const mapStateToProps = (state) => ({counters : state.counters});

/* 
    액션 생성자를 사용하여 액션을 만들고
    해당 액션을 dispatch하는 함수를 만든 후 이를 props로 연결합니다.
*/
const mapDispatchToProps = (dispatch) => ({
    onIncrement : (index) => dispatch(actions.increment(index)),
    onDecrement : (index) => dispatch(actions.decrement(index)),
    onSetColor : (index) => {
        const color = getRandom();
        dispatch(actions.setColor({index,color}))
    }
})
const CounterListContainer = connect(mapStateToProps, mapDispatchToProps)(CounterList);

export default CounterListContainer;
```

이 코드에서 사용한 랜덤 색상 생성 함수는 다음에 수정할 App 컴포넌트에서도 사용합니다. 코드가 중복되므로 해당 함수는 lib 디텍토리에 저장한후 불러와 사용합니다.

```js
// src/lib/getRandomColor.js
export default function getRandomColor(){
     const colors = [
      '#495057',
      '#f03e3e',
      '#d6336c',
      '#ae3ec9',
      '#7048e8',
      '#4263eb',
      '#1c7cd6',
      '#1098ad',
      '#0ca678',
      '#37b24d',
      '#74b816',
      '#f59f00',
      '#f76707'
  ];
  const random = Math.floor(Math.random() * 13);
  return colors[random];
}
```

CounterListContainer 컴포넌트에서 getRandomColor 함수를 제거하고 위쪽에 함수를 불러옵니다.

```js
// src/containers/CounterListContainer.js
import CounterList from '../components/CounterList';
import * as actions from '../actions';
import {connect} from 'react-redux';
import getRandomColor from '../lib/getRandomColor';
...
```

# 13.2.5.2 App 컴포넌트 수정

다음으로 App 컴포넌트를 리덕스에 연결시킵니다. 이 컴포넌트에는 store에서 필요한 값이 없으므로 mapStateToProps는 null로 설정하고 버튼용 mapDispatchToProps를 만듭니다.

이 컴포넌트에서 onCreate와 onRemove를 만들고 Buttons 컴포넌트의 props로 전달합니다.

```js
// src/containers/App.js
import React , {Component} from 'react';
import Buttons from '../components/Buttons';
import CounterListContainer from './CounterListContainer';
import getRandomColor from '../lib/getRandomColor';

import {connect} from 'react-redux';
import * as actions from '../actions';

class App extends Component {
    render(){
        const {onCreate , onRemove} = this.props;
        return (
            <div className="App">
                <Buttons 
                onCreate={onCreate}
                onRemove={onRemove}/>
                <CounterLlistContainer/>
            </div>
        )
    }
}
const mapDispatchToProps = (dispatch) => ({
    onCreate : () => dispatch(actions.create(getRandomColor())),
    onRemove : () => dispatch(actions.remove())
})

export default connect(null, mapDispatchToProps)(App);
```

만든 컴포넌트를 불러와 이를 디럭스에 연결하는 것이 아니라, 파일 하나에 컴포넌트를 정의하고 바로 연결해 주었습니다. 이때 AppContainer의 레퍼런스를 따로 만들 필요 없이 export 하는 부분에서 connect를 사용하여 바로 리덕스에 연결시키면 됩니다.

# 13.3 정리

리액트에서 리덕스를 사용했을 때 크게 달라지는 점은 상태를 컴포넌트 내부가 아닌 리듀서에서 관리하면서 코드가 분리 된다는 것입니다.

그렇기 때문에 컴포넌트들 만들 때 상태보다는 사용자에게 보이는 뷰에 더욱 집중할 수 있습니다.


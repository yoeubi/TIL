# 6.4 응용

이번에는 동적인 데이터를 렌더링합니다.

# 6.4.1 state에 초기 데이터 담기

기존 상수에 담았던 배열을 컴포넌트의 state에 담았습니다.

```js
// IterationSample.js
import React , {Component} from 'react';

class IterationSample extends Component {
    state = {
        names : ['눈사람','얼음','눈','바람']
    }
    render(){
        const nameList = this.state.names.map(
            (name,index) => (<li key={index}>{name}</li>)
        )
        return (
            <ul>
                {nameList}
            </ul>
        )
    }
}
export default IterationSample;
```

# 6.4.2 데이터 추가 기능

데이터 추가 기능을 구현하려면 먼저 위쪽에 input 과 button을 렌더링 하고 , 이벤트 핸들러 메서드를 만들어야합니다.

```js
// IterationSample.js
import React , {Component} from 'react';

class IterationSample extends Component {
    state = {
        names : ['눈사람','얼음','눈','바람'],
        name : ''
    }
    handleChange = (e) => {
        this.setState({
            name : e.target.value
        })
    }
    handleInsert = () => {
        this.setState({
            names : this.state.names.concat(this.state.name),
            name : ''
        })
    }
    render(){
        const nameList = this.state.names.map(
            (name,index) => (<li key={index}>{name}</li>)
        )
        return (
            <div>
                <input
                    onChange={this.handleChange}
                    value={this.state.name}/>
                <button onClick={this.handleInsert}>추가</button>
                <ul>
                    {nameList}
                </ul>
            </div>
        )
    }
}
export default IterationSample;
```

input 값은 기본 값이 공백으로 state에 저장했고, 컴포넌트 위쪽에 input 과 button이 위치할 수 있도록 렌더링될 코드를 div태그로 감쌌습니다.

그리고 input 과 button에서 필요한 이벤트 핸들러 메서들르 준비하여 각 요소에 이벤트를 설정해 주었습니다.

handelInsert 메서드에서 배열에 새 데이터를 추가하는 방식이 조금 다릅니다.

this.state.names.push 로 배열을 수정해도 되지 않을까라고 생각할 수 있지만 state는 언제나 setState 메서드로 업데이트 해야 하고 직접 접근하여 수정하면 안됩니다.

push같은 함수를 쓴다면 기존 배열 자체가 변형되미로 이는 잘못 사용한 것입니다. 자동으로 리렌더링을 트리커하지 않기 때문입니다.

따라서 기존 배열을 직접 수정하지 않고, 기존 배열과 새 값을 합친 새 배열을 생성하는 concat을 사용하면 됩니다.

# 6.4.3 데이터 제거 기능 구현

아이템을 두번 클릭하면 제거하도록 만들겠습니다. 요소를 두번 클릭할 때 사용하는 이벤트 이름은 onDoubleClick입니다.

```js
// IterationSample.js
import React , {Component} from 'react';

class IterationSample extends Component {
    state = {
        names : ['눈사람','얼음','눈','바람'],
        name : ''
    }
    ...

    handleRemove = (index) => {
        const {names} = this.state;

        this.setState({
            names : [
                ...names.slice(0,index),
                ...names.slice(index + 1, names.length)
            ]
        })
    }

    render(){
        const nameList = this.state.names.map(
            (name,index) => (
                <li
                    key={index}
                    onDoubleClick={() => this.handleRemove(index)}>
                    {name}
                </li>
            )
        )
        return (
            ...
        )
    }
}
export default IterationSample;
```

handelRemove 메서드에서 사용한 ...문법은 ES6의 전개 연산자라고 합니다. 이 문법이 하는 역활은 ... 뒤에 위치란 배열 값을 그대로 꺼내서 현재 배열에 복사하는 것입니다.

handelRemove는 배열 내장 함수 slice를 사용하여 배열의 0부터 주어진 index 전까지 원소들을 가진 새 배열을 만듭니다.

또 index + 1 부터 마지막까지 원소들을 가진 새 배열을 만든 후 전개 연산자를 사용하여 배열 하나로 합쳐 줍니다.

전개 연산자를 사용하는 이유는 소스 코드의 간결함과 가독성 때문입니다.

전개 연산자를 사용하지 않았다면 slice한 배열을 concat했어야 하는데, 코드가 길고 가독성도 떨어집니다.

```js
// ES5 문법을 사용한 코드
this.state.names.slice(0, index).concat(this.stata.names.slice(index + 1 , this.state.names.length))
```

li 요소를 더블클릭했을때 실행되도록 설정할때는 화살표 함수로 내부에서 새로운 함수로 만들었습니다. 

그 이유는 index 값을 함수의 인수로 설정하기 위해서 입니다.

임의 메서드에 파리미터가 있을 때는 사용할 때 내부에서 함수를 새로 만들면 됩니다.

삭제 함수를 조금 더 간단하게 작성하고 싶다면 배열 내장 함수인 filter를 사용합니다.

해당 함수는 배열에서 특정 조건을 만족하는 값들만 추출하여 새로운 배열을 만듭니다.

```js
// IterationSample - handleRemove
handleRemove = index => {
    const {names} = this.state;
    this.setState({
        names: names.filter((item,i) => i !== index)
    })
}
```

# 6.5 정리

컴포넌트 배열을 렌더링할때는 key 값 설정에 항상 주의해야 합니다. 또는 key 값은 언제나 유일해야 합니다. key 값이 중복된다면 렌더링 과정에서 오류가 발생합니다.

상태 안에서 배열을 변형할때는 배열에 직접 접근하여 수정하는 것이 아니라 concat, slice, 전개 연사자, filter 함수등을 사용해서 새로운 배열을 만든 후 setState 메서드로 적용합니다.


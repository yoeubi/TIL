리덕스를 사용하여 멀티 카운터를 만들어서 조금은 불편했습니다. 약션을 만들때마다 세 가지 파일(액션 타입, 액션 생성 함수, 리듀서)를 수정해야 한다는 점, 전개 연산자와 slice 함수로 배열 내부의 원소를 수정하는데 가독성이 낮다는 점입니다.

- Immutable.js를 이용한 상태 업데이트
- Ducks 파일 구조
- redux-actions를 이용한 더욱 쉽게 액션 생성 함수 만들기

# 14.1 Immutable.js 익히기

Immutable.js는 자바스크립트에서 불변성 데이터를 다룰 수 있도록 도와줍니다.

# 13.1.1 객체 불변성

```js
let a = 7;
let b = 7;

let object1 = { a: 1 , b: 2 };
let object2 = { a: 1 , b: 2 };
```

a와 b의 값은 같습니다. 하지만 object1 과 object2가 가진 값이 동일하더라도 서로 다른 객체이기 때문에 둘을 비교하면 false를 반환합니다.

```js
object1 === object2 // false
```

```js
let object3 = object1;
object1 === object3 // true
```

object3에 object1을 넣고, 두 값을 비교하면 true를 반환합니다. object1과 object3은 같은 객체를 가리키기 때문입니다.

```js
object3.c = 3;
object1 === object3 // true
object1 // { a: 1 , b: 2 , C: 3 }
// object1에도 c 값이 생성 됩니다.
let array1 = [0,1,2,3,4,5];
let array2 = array1;
array2.push(5)
array1 === array2 // true
```

리액트 컴포넌트는 state 또는 상위 컴포넌트에서 전달받은 props 값이 변할 때 리렌더링 되는데, 배열이나 객체를 직접 수정한다면 내부 값이 변경되었을 지라도 레퍼런스가 가리키는 곳은 같이 때문에 동일한 값으로 인식합니다.

이런 이슈 때문에 객체나 배열을 업데이트 할때 전개 연산자를 사용해서 기존 값을 가진 새 객체 또는 배열을 만들었습니다.

그렇게 작업하다 보면 간단한 변경을 구현하는 데도 코드가 복잡할 때가 있습니다.

```js
let object1 = {
    a : 1,
    b : 2,
    c : 3,
    d : {
        e : 4,
        f : {
            g : 5,
            h : 6
        }
    }
}
// h 값을 10으로 수정합니다.
let object2 = {
    ...object1,
    d : {
        ...object1.d,
        f : {
            ...object1.d.f,
            h : 10
        }
    }
}
```

만약 객체 불변성을 유지할 필요가 없다면 다음과 같이 간단하게 할 수 있습니다.

```js
object1.d.f.h = 10;
```

이런 작업을 간소화하려고 페이스북 팀이 만든 라이브러리가 바로 Immutable.js입니다. 이 라이브러리를 사용하면 이 코드는 다음 형식으로 작성할 수 있습니다.

```js
let object1 = Map({
    a : 1,
    b : 2,
    c : 3,
    d : Map({
        e : 4,
        f : Map({
            g : 5,
            h : 6
        })
    })
})
let object2 = object1.setIn(['d','f','h'],10);

object1 === object2 // false
```

# 14.1.2 Map

Immutable의 Map은 객체 대신 사용하는 데이터 구조입니다. 자바스크립트에 내장된 Map과는 다릅니다.

# 14.1.2.1 실습 준비

CDN을 이용해서 Immutable.js를 불러옵니다. JSBin에 접속하고, HTML 영역에 추가합니다.

위쪽 버튼을 눌러 JavaScript 와 Console 영역만 남기고 다른 영역은 숨깁니다.

# 14.1.2.2 사용

Map 사용법 입니다.

```js
const {Map} = Immutable;

const data = Map({
    a : 1,
    b : 2
})
```

Map을 사용할 때는 Map 함수 안에 객체를 넣어서 호출합니다. 여러 층으로 구성된 Map은 다음과 같이 작성합니다.

```js
const {Map} = Immutable;

const data = Map({
    a : 1,
    b : 2,
    c : Map({
        d : 3,
        e : 4,
        f : 5
    })
})
```

객체 내부에 또 다른 객체들이 있다면 내부 객체들도 Map으로 감싸 주어야 나중에 사용하기 편합니다. 그리고 내부에서 Map을 사용하지 않으면 추후 setIn, getIn을 활용할 수 없습니다.

객체 내용을 네트워크에서 받아 오거나 전달받는 객체가 너무 복잡한 상태라면 내부까지 Map으로 만들기 힘든데 그때 fromJS를 사용합니다.

```js
const {Map, fromJS} = Immutable;

const data = fromJS({
    a : 1,
    b : 2,
    c : {
        d : 3,
        e : 4,
        f : 5
    }
})
```

fromJS를 사용하면 내부에 있는 객체들은 Map을 쓰지 않아도 됩니다.

Immutable 데이터를 실제로 활용하거나 수정할때는 내장 함수를 사용해야 합니다.

예를 들어 data 내부의 a 값을 참조하고 싶다면 data.a로 작성하는 것이 아니라, data.get('a')를 해야 합니다.

## 자바스크립트 객체로 변환

Immutable 객체를 일반 객체 형태로 변환하는 방법은 다음과 같습니다.

```js
const deserialized = data.toJS();
console.log(deserialized); // { a: 1 , b: 2, c: { d: 3 , e: 4 }}
```

## 특정 키의 값을 가져오기

특정 키의 값을 가지고 올때는 get 함수를 사용합니다.

```js
data.get('a') // 1
```

## 깊숙이 위치하는 값 불러오기

Map 내부에 또 Map이 존재하고, 그 Map 안에 있는 키 값을 불러올 때는 getIn 함수를 사용합니다.

```js
data.getIn(['c','d']) // 3
```

## 값 설정

새 값을 설정할때는 get 대신 set을 사용합니다.

```js
const newData = data.set('a',4)
```

set을 한다고 해서 데이터가 실제로 변하는 것은 아닙니다. 주어진 변화를 적용한 새 Map을 만듭니다.

```js
console.log(newData === data);
```

서로 다른 Map이기 때문에 false를 출력합니다, 기존 data 값은 그대로 남아 있고 ,변화가 적용된 데이터를 newData에 저장하는 것입니다.

## 깊숙이 위치하는 값 수정

깊숙이 위치하는 값을 수정할 때는 setIn을 사용합니다. 이때 내부에 있는 객체들도 Map 형태여야만 사용할 수 있다는 점입니다.

```js
const newData = data.setIn(['c','d'],10)
```

## 여러 값 동시에 설정

값 여러 개를 동시에 설정해야 할 때는 mergeIn을 사용합니다. 예를 들어 c의 d값, c의 e값을 동시에 바꿔야할 때는 코드를 다음과 같이 입력합니다.

```js
const newData = data.mergeIn(['c'], {d : 10, e : 10})
```

이렇게 mergeIn을 사용하면 c 안에 있는 f값은 그대로 유지하면서 d값과 e 값만 변경합니다. 또는 코드를 다음과 같이 입력할 수 있습니다.

```js
const newData = data.setIn(['c','d'],10).setIn(['c','d'],10);
```

그리고 최상위에서 merge를 해야할 때는 코드를 다음과 같이 입력합니다.

```js
const newData = data.merge({a:10,b:10})
```

set을 여러번 할지, 아니면 merge를 할지는 그때그때 상황에 맞추면 되지만, 성능상으로는 set을 여러번 하는것이 더 빠릅니다.

# 14.1.3 List

List는 Immutable 데이터 구조로 배열 대신 사용합니다. 배열과 동일하게 map, filter, sort, push, pop 함수를 내장하고 있습니다.

이 내장 함수를 실행하면 List 자체를 변경하는 것이 아니라 새로운 List를 반환합니다.

또 리액트 컴포넌트는 List 데이터 구조와 호환되기 때문에 map 함수를 사용하여 데이터가 들어있는 List를 컴포넌튼 List로 변환하여 JSX에서 보여 주어도 제대로 렌더링 됩니다.

# 14.1.3.1 생성

List는 다음과 같이 만듭니다.

```js
const {List} = Immutable;
const list = List([0,1,2,3,4,5]);
```

객체들의 List를 만들어야 할 때는 다음과 같이 객체들은 Map으로 만들어야 추후 get과 set을 사용할 수 있습니다.

```js
const {List, Map, fromJS} = Immutable;
const list = List([
    Map({ value : 1}),
    Map({ value : 2})
]);
// or

const list2 = fromJS([
    { value : 1 },
    { value : 2}
])
```

fromJS를 사용하면 내부 배열을 List로 만들고 내부 객체는 Map으로 만듭니다.

그리고 Map과 마찬가지로 List도 toJS를 사용하여 일반 배열로 변환할 수 있습니다. 이 과정에서 내부에 있는 Map들도 자바스크립트 객체로 변환됩니다.

```js
console.log(list.toJS())
```

# 14.1.3.2 값 읽어 오기

n번째 원소 값은 get(n)을 사용하여 읽어 옵니다.

```js
list.get(0);
```

0번째 아이템의 value 값은 다음과 같이 읽어 옵니다.

```js
list.getIn([0, 'value'])
```

# 14.1.3.3 아이템 수정

n번째 아이템을 수정해야 할 때는 set과 setIn을 사용합니다. 원소를 통째로 바꾸고 싶을 때는 다음과 같이 set을 사용합니다.

```js
const newList = list.set(0, Map({ value : 10 }))
```

List의 Map 내부 값을 변경하고 싶을 때는 다음과 같이 setIn을 사용합니다.

```js
const newList = list.setIn([0, 'value'],10)
```

다른 방법으로는 update를 사용할 수도 있습니다.

```js
const newList = list.update(0, item => item.set('value', item.get('value') * 5))
```

값을 업데이트해야 하는데 기존 값을 참조해야 할 때는 이처럼 update를 사용하면 편합니다. 첫 번째 파라미터는 선택할 인덱스 값, 두 번째 파라미턴느 선택한 원소를 업데이트 하는 함수입니다. 업데이트를 사용하지 않는다면 다음과 같이 작성해야 합니다.

```js
const newList = list.setIn([0,'value'], list.getIn([0,'value'] * 5));
```

# 14.1.3.4 아이템 추가

아이템을 추가할때는 push를 사용합니다. 이 함수를 사용한다고 해서 Array처럼 기존 List 자체에 아이템을 추가하는 것은 아닙니다. 

```js
const newList = list.push(Map({value : 0}))
```

리스트 맨 뒤가 아니라 맨 앞에 데이터를 추가하고 싶다면 push 대신 unshift를 사용합니다.

```js
const newList = list.unshift(Map({value : 0}))
```

# 14.1.3.5 아이템 제거

아이템을 제거할 때는 delete를 사용합니다.

```js
const newList = list.delete(1);
```

Array가 가진 내장 함수를 List도 대부분 가지고 있습니다. 예를 들어 마지막 아이템을 제거하고 싶다면 pop을 사용해도 됩니다.

```js
const newList = list.pop();
```

# 14.1.3.6 List 크기 가져오기

배열 크기를 가져올 때는 length를 참조하지만, List에서는 length가 아니라 size를 참조해야 합니다.

```js
console.log(list.size)
```

비어 있는지 확인하고 싶다면 .isEmpty() 를 사용할 수 있습니다.

```js
list.isEmpty();
```


# 14.4 일정 관리 애플리케이션에 리덕스 적용

# 14.4.1 준비

기존에 만든 프로젝트에서 리덕스를 사용하려면 먼저 다음 명령어로 필요한 의존 모듈들을 설치해야 합니다.

```bash
yarn add redux react-redux redux-actions immutable
```

그리고 src 디렉토리에 modules와 containers 디렉토리를 생성합니다. modules 디렉토리에는 Ducks구조를 적용한 리덕스 관련 코드를 넣고, containers 디렉토리에는 리덕스 스토어에 연결된 컴포넌트들을 넣을 것입니다.

# 14.4.2 모듈 생성

인풋 상태를 관리하는 input 모듈과 일정들의 상태를 관리하는 todos 모듈을 만들 것입니다.

# 14.4.2.1 input 모듈 생성

이번에 모듈을 만들 때는 이전에 배운 Immutable과 redux-actions를 사용하므로 다음 코드 두 줄로 시작합니다.

```js
// src/modules/input.js
import {Map} from 'immutable';
import {handleActions, createAction} from 'react-actions';
```

리덕스 상태에서 일반 자바스크립트 객체가 아닌 Immutable의 Map 구조를 사용하므로 Immutable 모듈을 불러왔고, handleActions와 createAction을 사용하려고 redux-actions를 불러왔습니다.

인풋 모듈에서는 현재 인풋 내용을 설정하는 액션 하나만 있으면 충분합니다.

```js
// src/modules/input.js
...
const SET_INPUT = "input/SET_INPUT";
```

액션 타입을 정의할 때는 문자열의 앞부분에 리듀서 이름을 적어 줍니다. 이렇게 접두사를 설정했을 때 장점은 액션 타입 이름이 서로 다른 리듀서끼리 중복되어도 상관없다는 것입니다.

액션 타입을 정의하고 나서 createAction을 사용하여 액션 생성 함수를 만듭니다.

```js
// src/modules/input.js
...
export const setInput = createAtion(SET_INPUt);
```

그다음 순서는 리듀서의 초기 상태를 정의하는 것입니다.

```js
// src/modules/input.js
...
const initialState = Map({
    value : ''
})
```

value 값을 Map안에 넣었습니다. 이제 리듀서를 만들 차례입니다. 리듀서는 handleActions를 사용하여 만듭니다.

```js
// src/modules/input.js
export default handleActions({
    [SET_INPUT] : (state, action) => {
        return state.set('value', action.payload)
    }
}, initialState)
```

# 14.4.2.2 todos 모듈 생성

todos 모듈에서 구현할 액션은 다음 세 가지입니다.

- INSERT : 추가
- TOGGLE : 토글
- REMOVE : 삭제

그럼 우선 액션 타입을 정의하고, 액션 생성 함수를 만듭니다.

```js
// src/modules/todos.js
import {Map,List} from 'immutable';
import {handleActions, createAction} from 'react-actions';

const INSERT = 'todos/INSERT';
const TOGGLE = 'todos/TOGGLE';
const REMOVE = 'todos/REMOVE';

export const insert = createAction(INSERT);
export const toggle = createAction(TOGGLE);
export const remove = createAction(REMOVE);
```

그 다음은 리듀서의 기본 상태도 정의 합니다.

```js
// src/modules/todos.js
...
const initialState = List([
    Map({
        id : 0 ,
        text : '리액트 공부하기',
        done : true
    }),
    Map({
        id : 1,
        text : '컴포넌트 스타일링 해보기',
        done : false
    })
])
```

리듀서의 기본 상태는 List로 만들었습니다. 그리고 내부에는 초기에 지니고 있을 일정 데이터 두 개를 Map형태로 넣어 주었습니다.

handleActions를 사용하여 리듀서를 만들어 보겠습니다.

```js
// src/modules/todos.js
...
export default handleActions({
    [INSERT] : (state,action) => {
        /* 
            payload 안에 있는 id, text, done의 레퍼런스를 만들어 줍니다.
            레퍼런스를 만들지 않고 , 바로 push(Map(action.payload))를 해도 되지만,
            나중에 이 코드를 보았을 때 ,
            이 액션이 어떤 데이터를 처리하는지 쉽게 볼수 있돌고 하는 작업입니다.
        */
        const {id, text, done} = action.payload;
        return state.push(Map({
            id,
            text,
            done
        }))
    }, 
    [TOGGLE] : (state,action) => {
        const { payload : id} = action;
        // = const id = action.payload;
        /* 
            비구조화 할당으로 id 레퍼런스에 action.payload 값을 넣습니다.
            이 작업은 필수는 아니지만, 나중에 이 코드를 보았을때 여기에서 payload가 
            어떤 값을 의미하는지 쉽게 이해할 수 있습니다.
        */
        // 전달받은 id 를 가지고 index를 조회합니다.
        const index = state.findIndex(todo => todo.get('id') === id);
        // updateIn으로 현재 값을 참조하여 반대 값으로 설정합니다.
        return state.updateIn([index, 'done'], done => !done );
        /* 
            updateIn을 사용하지 않는다면 다음과 같이 작성할 수 도 있습니다.
            return state.setIn([index,'done'], !state.getIn([index, 'done']))
        */
    },
    [REMOVE] : (state,action) => {
        const {payload : id } = action;
        const index = state.findIndex(todo => todo.get('id') === id);
        return state.delete(index);
    }
}, initialState)
```

# 14.4.2.3 모듈 인덱스 파일 생성

이제 modules 디렉토리에 index.js 파일을 만들고 combineReducers를 사용하여 리듀서를 합쳐서 내보냅니다.

```js
// src/modules/index.js
import input from './input';
import todos from './todos';
import {combineReducers} from 'redux';

export default combineReducers({
    input,
    todos
})
```

# 14.4.3 스토어 생성 및 설정

모듈을 다 만들었으니 index.js에서 리덕스 스토어를 생성하고, Provider로 리액트 프로젝트에 적용해 봅니다.

```js
// src/index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './styles/main.scss';
import App from './components/App';

import modules from './modules';
import {createStore} from 'redux';
import {Provider} from 'react-redux';

const store = createStore(modules, window.devToolsExtension && window.devToolsExtension());

ReactDOM.render(
    <Provider store={store}>
        <App/>
    </Provider>,
    document.getElementById('root')
)
```

# 14.4.4 컨테이너 컴포넌트 생성

이제 컨테이너 컴포넌트를 만들어 보겠습니다. TodoInputContainer, TodoListContainer 두 개 입니다.

# 14.4.4.1 TodoInputContainer 생성

각 메서드를 구현하기 전에 먼저 store의 상태와 액션 생성 함수를 연결하겠습니다.

```js
// src/containers/TodoInputContainer.js
import React , {Component} from 'react';
import TodoInput from '../components/TodoInput';

import {connect} from 'react-redux';
import {bindActionCreators} from 'react';

import * as inputActions from '../modules/input';
import * as todosActions from '../modules/todos';

class TodoInputContainer extends Component {
    render(){
        return (
            <TodoInput/>
        )
    }
}

/* 
    이번에는 mapStateToProps 와 mapDispatchToProps 함수에 대한 레퍼런스를 
    따로 만들지 않고, 그 내부에서 바로 정의하겠습니다.
*/
export default connect(
    (state) => ({
        value : state.input.value
    }),
    (dispatch) => ({
        /* 
            bindActionCreators를 사용하면 다음 작업들을 합니다.
            {
                actionCreator : (...params) => dispatch(actionCreator(...params))
            }
            그래서 이전에 우리가 했던 것처럼 일일이 dispatch할 필요가 없습니다.
            예를 들어 InputActions에는 다음 작업이 되어 있는 것이죠.
            InputActions : {
                setInput : (value) => dispatch(inputActions.setInput(value))
            }
            나중에 이를 호출할 때는 this.props.InputActions.setInput을 호출하면 됩니다.
        */
        InputActions : bindActionCreators(inputActions, dispatch),
        TodosActions : bindActionCreators(todosActions, dispatch)
    })
)(TodoInputContainer);
```

액션 생성 함수들을 연결시켜 주는 과정에서 리덕스의 내장 함수 중 하나인 bindActionCreators를 사용했습니다. 

이 함수의 첫 번째 파라미터는 액션 생성 함수들이 들어 있는 객체고, 두 번째 파라미터는 dispatch입니다.

이 함수를 사용하면 액션 생성 함수 여러 개를 손쉽게 설정할 수 있습니다. 

이제 컴포넌트에 필요한 메서드들을 구현하고, TodoInput에 필요한 props들을 전달합니다.

```js
// src/containers/TodoInputContainer.js
...
class TodoInputContainer extends Component {
    id = 1;
    getId = () => {
        return ++this.id;
    }
    handleChange = (e) => {
        const {value} = e.target;
        const {InputActions} = this.props;
        InputActions.setInput(value)
    }
    handleInsert = () => {
        const {InputActions, TodosActions, value} = this.props;
        const todo = {
            id : this.getId(),
            text : value,
            done : false
        };
        TodoActions.insert(todo);
        InputActions.setInput('');
    }
    render(){
        const { value } = this.props;
        const { handleChange, handleInsert } = this;
        return (
            <TodoInput 
                onChange={handleChange}
                onInsert={handleInsert}
                value={value}
            >
            
            </TodoInput>
        )
    }
}
...
```

setState를 하던 부분을 모두 리덕스의 액션 생성 함수를 호출하는 것으로 변경했습니다.

# 14.4.4.2 TodoListContainer 생성

TodoList 컴포넌트를 리덕스에 연결한 TodoInputContainer를 만들겠습니다. 우선 컴포넌트에 리덕스의 상태와 액션 생성 함수들을 연결하겠습니다.

```js
// src/containers/TodoListContainer.js
import React , {Component} from 'react';
import TodoList from '../components/TodoList';

import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';

import * as todosActions from '../modules/todos';

class TodoListContainer extends Component {
    render(){
        return (
            <TodoList />
        )
    }
}
export default connect(
    (state) => ({
        todos : state.todos
    }),
    (dispatch) => ({
        TodosActions : bindActionCreators(todosActions, dispatch)
    })
)(TodoListContainer)
```

props를 TodoList에 전달합니다. 

```js
// src/containers/TodoContainer.js
class TodoListContainer extends Component {
    handleToggle = id => {
        const {TodosActions} = this.props;
        TodosActions.toggle(id);
    };
    handleRemove = id => {
        const { TodosActions } = this.props;
        TodosActions.remove(id);
    }
    render(){
        const { todos } = this.props;
        const { handleToggle , handleRemove } = this;
        return (
            <TodoList
                todos={todos}
                onToggle={handleToggle}
                onRemove={handleRemove}/>
        ) 
    }
}
```

리덕스를 사용하면 이렇게 상태 업데이트 로직, UX와 뷰 코드가 분리되어서 관리하기 쉽다는 장점이 있습니다.

# 14.4.5 프로젝트 마무리

현재 TodoList 컴포넌트는 todos를 객체로 구성된 배열로 받도록 되어 있는데, Map들로 구성된 List 형태의 객체를 전달했으니 이에 맞추어 코드를 수정해야합니다.

```js
// src/components/TodoList/TodoList.js
    render(){
        const { todos , onToggle, onRemove } = this.props;
        const todoList = todos.map(
            todo => (
                <TodoItem
                    key={todo.get('id')}
                    done={todo.get('done')}
                    onToggle={() => onToggle(todo.get('id'))}
                    onRemove={() => onRemove(todo.get('id'))}>
                    {todo.get('text')}
                </TodoItem>
            )
        )
        return (
            <div>
                {todoList}
            </div>
        )
    }
```

기존에는 바로 todo.id, todo.text 식으로 바로 객체 내부 값에 접근했지만, todos 안에 들어 있는 데이터들은 Map이므로 get 함수를 사용하여 각 값을 조회해야 합니다.

App.js 파일의 코드를 수정하겠습니다. 

```js
// src/components/App.js
import React , {Component} from 'react';
import PageTemplate from './PageTemplate';
import TodoInputContainer from '../containers/TodoInputContainer';
import TodoListContainer from '../containers/TodoListContainer';

class App extends Component {
    render(){
        return (
            <PageTemplate>
                <TodoInputContainer/>
                <TodoListContainer/>
            </PageTemplate>
        )
    }
}
export default App;
```

# 14.5 정리

리덕스의 가장 큰 장점은 상태 관리를 하는 로직과 뷰에 관련된 로직을 완전히 다른 파일로 분리함으로써 프로젝트 가독성을 높이고 유지 보수를 하기도 쉽다는 것입니다. 

추가로 리덕스에 상태를 넣으면 개발자 도구를 이용하여 프로젝트의 상태를 한눈에 볼 수 있습니다.


# 15.2 비동기 작업을 처리하는 미들웨어 사용

# 15.2.1 redux-thunk

리덕스를 사용하는 애플리케이션에서 비동기 작업을 처리할 때 가장 기본적인 방법은 redux-thunk 미들웨어를 사용하는 것입니다.

# 15.2.1.1 thunk란?

thunk는 특정 작업을 나중에 할 수 있도록 미루려고 함수 형태로 감싼 것을 의미합니다.

예를 들어 우리가 1 + 2 를 지금 당장 연산하고 싶다면 이렇게 입력합니다

```js
const x = 1 + 2;
```

이 코드를 실행하면 1 + 2 연산을 바로 진행합니다. 하지만 코드를 다음과 같이 입력하면 어떨까요?

```js
const foo = () => 1 + 2;
```

이렇게 하면 1 + 2 연산을 코드가 실행될때 바로 하지 않고 나중에 foo 함수를 호출할때 합니다.

# 15.2.1.2 redux-thunk는 무엇을 하는 미들웨어일까?

이 미들웨어는 객체가 아닌 함수도 디스패치할 수 있게 합니다. 일반 액션 객체로는 특정 액션을 디스패치한 후 몇 초 뒤에 실제로 반영시키거나 현재 상태에 따라 아예 무시하게 만들 수 없습니다.

redux-thunk 미들웨어는 함수를 디스패치할수 있게 함으로써 일반 액션 객체로는 할수 없는 작업들도 할 수 있게 합니다.

우선 1초 뒤에 액션이 디스패치 되는 코드를 봅니다.

```js
const INCREMENT_COUNTER = 'INCREMENT_COUNTER';

function increment(){
    return {
        type : INCREMENT_COUNTER
    }
}

function incrementAsync(){
    // dispatch를 파라미터로 가지는 함수를 리턴합니다.
    return dispatch => {
        setTimeout(() => {
            // 1초 뒤 dispatch합니다.
            dispatch(increment());
        }, 1000 )
    }
}
```

이렇게 하면 나중에 store.dispatch(incrementAsync())를 했을 때 INCREMENT_COUNTER 액션을 1초 뒤에 디스패치합니다.

이번에는 조건에 따라 액션을 디스패치하거나 무시하는 코드를 살펴봅니다

```js
function incrementIfOdd(){
    return (dispatch, getState) => {
        const {counter} = getState();
        if(counter % 2 === 0){
            return ;
        }
        dispatch(increment());
    }
}
```

리턴하는 함수에서 dispatch, getState를 파리미터로 받게 한다면 스토어 상태에서 접근할수 있습니다.

따라서 현재 스토어 상태 값에 따라 액션을 디스패치할지, 아니면 무시할지 정할 수 있습니다.

객체가 아니라 이렇게 함수를 반환하는 함수는 액션 생성 함수라 하지 않고 thunk 생성 함수라고 합니다.

thunk 생성 함수에서는 dispatch와 getState 를 파라미터로 가지는 새로운 함수를 만들어서 반환해야 합니다.

이 thunk 생성 함수는 내부에서 여러 가지 작업을 할 수 있습니다. 이곳에서 네트워크 요청을 해도 되며, 이 안에서 또 다른 종류의 액션들을 여러 번 디스패치할 수도 있습니다.

# 15.2.1.3 설치와 적용

```bash
yarn add redux-thunk
```

다음으로 스토어를 생성할때 미들웨어를 적용합니다.

```js
// src/store.js
import {createStore, applyMiddleware} from 'redux';
import modules from './modules';

import {createLogger} from 'redux-logger';
import ReduxThunk from 'redux-thunk';

const logger = createLogger();

const store = creaStore(modules, applyMiddleware(logger, ReduxThunk));

export default store;
```

# 15.2.1.4 카운터를 비동기적으로 생성

이제 기존에 작동하던 카운터가 비동기적으로 작동하도록 코드를 추가해 보겠습니다. 액션을 디스패치할 때, 1초 뒤에 실제 액션을 디스패치하도록 코드를 다음과 같이 수정합니다.

```js
// src/modules/counter.js
import {handleActions, createAction } from 'redux-actions';

const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

export const increment = createAction(INCREMENT);
export const decrement = createAction(DECREMENT);

export const incrementAsync = () => dispatch => {
    // 1초 뒤 액션 디스패치
    setTimeout(
        () => { dispatch(increment())},
        1000
    )
}
export const decrementAsync = () => dispatch => {
    // 1초 뒤 액션 디스패치
    setTimeout(
        () => { dispatch(decrement())},
        1000
    )
}
export default handleActions({
    [INCREMENT] : (state,action) => state + 1,
    [DECREMENT] : (state,action) => state - 1
}, 0)
```

INCREMENT 또는 DECREMENT 액션을 1초 뒤에 디스패치하는 액션 함수 incrementAsync와 decrementAsync를 만들었습니다.

리덕스 모듈을 이렇게 수정한 후에는 App 컴포넌트를 열어 increment 와 decrement 뒤에 Async를 붙여줍니다.

```js
// src/App.js
<button onClick={CounterActions.incrementAsync}>+</button>
<button onClick={CounterActions.decrementAsync}>-</button>
```

코드를 수정하고 나서 카운터 버튼을 누르면 이렇게 함수형 액션을 먼저 디스패치하고 1초 뒤에 우리가 지정한 액션을 디스패치합니다.

# 15.2.2 웹 요청 처리

redux-thunk를 사용하여 비동기 작업을 처리해 보겠습니다. 우리는 axios라는 Promise 기반 HTTP 클라이언트 라이브러리를 사용하여 웹 요청을 하겠습니다.

# 15.2.2.1 Promise란?

Promise는 ES6 문법에서 비동기 처리를 다루는 데 사용하는 객체입니다. 예를 들어 숫저랄 1초 뒤에 프린트하는 코드를 작성해 보겠습니다.

```js
function printLater(number){
    setTimeout(
        function(){
            console.log(number);
        },
        1000
    )
}

printLater(1)
```

printLater 함수 안에 파라미터로 값을 전달하면 1초 뒤 콘솔에 나타납니다. 이번에는 1초에 걸쳐서 숫자를 더해 가면서 1,2,3,4를 프린타흔ㄴ 코드를 작성해봅니다.

```js
function printLater(number, fn){
    setTimemout(
        function(){
            console.log(number)
            if(fn) fn()
        },
        1000
    )
}

printLater(1,function(){
    printLater(2, function(){
        printLater(3, function(){
            printLater(4);
        })
    })
})
// 1
// 2
// 3
// 4 
```

두 번째 파리미터에 그 다음 호출할 함수를 전달하여 4회차에 걸쳐서 숫자를 기록했습니다. 이렇게 비동기적으로 해야 할 작업이 많으면 코드 구조는 자연스레 깊어질 것이고 그러면 코드를 읽기 힘듭니다. 이런 깊고 복잡해진 코드를 콜백 지옥이라고도 합니다.

기존 자바스크립트의 이런 문제를 해결해 주는 것이 바로 Promise입니다. 앞 코드를 Promise로 해결해봅니다.

```js
function printLater(number){
    // 새 Promise를 만들어서 리턴합니다/
    return new Promise(
        resolve => {
            // 1초 뒤 실행하도록 설정합니다.
            setTimeout(
                () => {
                    console.log(number);
                    resolve(); // promise가 끝났음을 알립니다.
                },
                1000
            )
        }
    )
}

printLater(1)
    .then(() => printLater(2))
    .then(() => printLater(3))
    .then(() => printLater(4))
```

printLater를 몇 번 해야 하든 코드 깊이는 일정합니다. 따라서 콜백 지옥에 빠질 걱정을 하지 않아도 됩니다. Promise는 값을 리턴하거나 오류를 발생시킬수도 있습니다.

Promise에서 결과 값을 반환할때는 resolve(결과 값)을 작성하고 오류를 발생시킬 때는 reject(오류)를 작성합니다. 여기에서 반환하는 결과 값과 오류는 then 과 catch에 전달하는 함수의 파라미터로 설정됩니다.

```js
function printLater(number){
    // 새 Promise를 만들어서 리턴합니다.
    return new Promise(
        // resolve, reject를 파리미터로 받습니다.
        (resolve, reject) => {
            if(number > 4){
                // reject 는 오류를 발생시킵니다.
                return reject('number is greater than 4');
            }
            setTimeout(
                () => {
                    console.log(number);
                    resolve(number + 1); // 현재 숫자에 1을 더한 값을 반환합니다.
                },
                1000
            )
        }
    )
}
printLater(1)
    .then((num) => printLater(num))
    .then((num) => printLater(num))
    .then((num) => printLater(num))
    .then((num) => printLater(num))
    .catch(e => console.log(e))
```

이번에는 결과가 5 이상이면 값을 처리하지 않고 오류를 발생시키고, 5 미만이면 현재 값에서 1을 더한 값을 반환하는 Promise를 작성했습니다.

printLater(1)이 처름 호출되면 비동기적으로 숫자 2를 반환하고, 이 값은 then쪽에 설정한 함수의 파라미터로 전달합니다. 그러면 다시 PrintLater를 호출하고 3을 반환합니다. 이렇게 순차적으로 5까지 숫자가 올라가면 오류가 발생합니다.

# 15.2.2.2 axios 사용

```bash
yarn add axios
```

그 다음에는 App 컴포넌트에서 axios를 불러오고 componentDidMount에서 axios를 사용하여 REST API를 요청하겠습니다. 예저로 사용할 API는 jsonplaceholder에서 제공하는 테스트용 가짜 API입니다.

```js
// src/App.js
import React , {Component} from 'react';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import * as counterActions from './modules/counter';
import axios from 'axios';

class App extends Component {
    componentDidMount(){
        axios.get('https://jsonplaceholder.typicode.com/posts/1')
            .then(response => console.log(response))
    }
}
```

axios로 웹 요청을 했을 때 반환돠는 객체는 해당 요청의 응답 정보를 지닌 객체입니다.

# 15.2.2.3 redux-thunk와 axios 사용

우선 modules 디텍토리에 post 모듈을 만듭니다. 그리고 API 함수와 액션 및 액션 생성 함수를 정의합니다.

```js
// src/modules/post.js
import {handleActions, createAction } from 'redux-actions';

import axios from 'axios';

function getPostAPI(postId){
    return axios.get(`https://jsonplaceholder.typicode.com/posts/${postId}`);
}

const GET_POST_PENDING = 'GET_POST_PENDING';
const GET_POST_SUCCESS = 'GET_POST_SUCCESS';
const GET_POST_FAILURE = 'GET_POST_FAILURE';

const getPostPending = createAction(GET_POST_PENDING);
const getPostSuccess = createAction(GET_POST_SUCCESS);
const getPostFailure = createAction(GET_POST_FAILURE);
```

postId를 파라미터로 받아 와서 axios를 사용하여 API 요청하는 함수를 만들었고, 요청을 시작할때, 성공했을 때, 실패했을 때 실행될 액션 타입과 액션 생성 함수를 정의했습니다.

해당 액션 생성 함수들은 모듈 내부에서 사용하니 export로 내보낼 필요가 없습니다.

다음으로 thunk를 만들어 요청 상태에 따라 액션을 디스패치합니다. 이번에 만들 thunk는 나중에 컴포넌트에서 불러와 사용해야 하므로 export를 입력하여 내보냅니다.

```js
// src/modules/post.js
...
export const getPost = (postId) => dispatch => {
    // 먼저 요청이 시작했다는 것을 알립니다.
    dispatch(getPostPending());

    // 요청을 시작합니다. 여기에서 만든 promise를 return해야 나중에 컴포넌트에서 
    // 호출을 할때 getPost().then()을 할 수 있습니다.
    return getPostAPI(postId).then((response) => {
        // 요청이 성공했다면 서버 응답 내용을 payload로 설정하여
        // GET_POST_SUCCESS 액션을 디스패치합니다.
        dispatch(getPostSuccess(response));
        // 나중에 getPostAPI.then을 했을 때 then에 전달하여
        // 함수에서 response에 접근할 수 있게 합니다.
        return response;
    }).catch(error => {
        // 오류가 발생하면 오류 내용을 payload로 설정하여
        // GET_POST_FAILURE 액션을 디스패치합니다.
        dispatch(getPostFailure(error));
        // error를 throw하여 이 함수를 실행한 후
        // 다시 한 번 catch를 할 수 있게 합니다.
        throw(error);
    })
}
```

앞 코드는 요청이 시작할 때 POST_PENDING 액션을 디스패치합니다. 그러고 나서 서버가 응답할 때까지 대기합니다. 우리가 나중에 이 액션이 디스패치되어 리듀서에서 이를 처리할 때 해당 요청이 대기 중이라는 상태를 설정하도록 구현하겠습니다.

요청을 시작한 후에는 서버가 성공적으로 응답할 수도 있고, 오류가 발생할 수도 있습니다. 요청이 끝나 성공했을 때는 POST_SUCCESS 액션을 디스패치합니다. 요청이 실패했다면 POST_FAILURE 액션을 디스패치합니다. 

해당 액션들을 리듀서에서 처리할 때는 기존에 대기 중으로 설정했던 상태를 비활성화하고, 결과 값 또는 오류를 상태에 넣을 수 있습니다.

thunk를 모두 작성했다면, 리듀서의 초기 상태를 정의하고 handleActions를 사용하여 리듀서 함수를 구현합니다.

```js
// src/post.js
const initialState = {
    pending : false,
    error : false,
    data : {
        title : '',
        body : ''
    }
}

export default handleActions({
    [GET_POST_PENDING] : (state,action) => {
        return {
            ...state,
            pending : true,
            error : false
        }
    },
    [GET_POST_SUCCESS] : (state, action) => {
        const { title, body } = action.payload.data;

        return {
            ...state,
            pending : false,
            data : {
                title,
                body
            }
        }
    },
    [GET_POST_FAILURE] : (state, action) => {
        return {
            ...state,
            pending : false,
            error : true
        }
    }
}, initialState )
```

새 모듈을 만들었으니, 이 모듈의 리듀서를 루트 리듀서에도 넣습니다.

```js
// src/index.js
import {combineReducers} from 'redux';
import counter from './counter';
import post from './post';

export default combineReducers({
    counter,
    post
})
```

컴포넌트에서 방금 만든 리덕스 모듈을 사용할 것입니다. 그 전에 카운터의 기본 값을 1로 설정합니다. 카운터 숫자를 postId로 사용하여 포스트를 요청할 것이기 때문입니다. 

```js
// src/modules/counter.js
export default handleActions({
    [INCREMENT] : (state,action) => state + 1,
    [DECREMENT] : (state,action) => state - 1
}, 1)
```

# 15.2.2.4 컴포넌트에서 액션으로 웹 요청 시도

기존의 App 컴포넌트에서는 axios를 직접 사용하여 웹 요청을 했습니다.

해당 코드를 지우고 + 버튼과 - 버튼을 눌렀을때 호출되는 incrementAsync 와 decrementAsync도 Async를 지워서 이전 상태로 돌립니다.

그 다음에는 post 모듈의 액션 생성 함수를 불러와 PostActions에 바인딩하고, post 모듈 안의 상태인 data, pendiing, error 값을 연결하세요.

```js
// src/App.js
import React , {Component} from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import * as counterActions from './modules/counter';
import * as postActions from './modules/post';

class App extends Component {
    componentDidMount(){
        // 추후 getPost 요청
    }
    render(){
        const {CounterActions, number} = this.props;

        return (
            <div>
                <h1>{number}</h1>
                <button onClick={CounterActions.increment}>+</button>
                <button onClick={CounterActions.decrement}>-</button>
            </div>
        )
    }
}
export default connect(
    (state) => ({
        number : state.counter,
        post : state.post.data,
        loading : state.post.pending,
        error : state.post.error
    }),
    (dispatch) => ({
        CounterActions : bindActionCreators(counterActions, dispatch),
        PostActions : bindActionCreators(postActions, dispatch)
    })
)(App)
```

다음으로 loadData를 만들겠습니다. 해당 메서드에서는 PostActions.getPost를 호출합니다. 파라미터는 현재 카운터의 값을 넣으세요. 그리고 이 메서드를 컴포넌트가 처음 마운트될때와 number값에 변경이 있을때 호출합니다.

```js
// src/App.js App 클래스 내부
...
class App extends Component {
    loadData = () => {
        const {PostActions, number} = this.props;
        PostActions.getPost(number);
    }
    componentDidMount(){
        this.loadData();
    }
    componentDidUpdate(prevProps, prevState){
        // 이전 number와 현재 number가 다르면 요청을 합니다.
        if(this.props.number !== prevProps.number){
            this.loadData();
        }
    }
    ...
}
```

이제 post 상태에 따라서 결과물을 렌더링합니다. App 컴포넌트의 render 함수를 수정합니다.

```js
// src/App.js
render(){
    const { CounterActions, number , post , error , loading } = this.props;
    return (
        <div>
            <h1>{number}</h1>
            {
                loading 
                    ? (<h2>로딩중...</h2>)
                    : (
                        error 
                        ? (<h2>오류 발생!</h2>)
                        : (
                            <div>
                                <h2>{post.title}</h2>
                                <p>{post.body}</p>
                            </div>
                        )
                    )
            }
            <button onClick={CounterActions.increment}>+</button>
            <button onClick={CounterActions.decrement}>-</button>
        </div>
    )
}
```

삼항 연산자가 익숙하지 않다면 해당 부분을 다음과 같이 입력할 수 있습니다.

```js
render(){
    const { CounterActions, number , post , error , loading } = this.props;

    return (
        <div>
            <h1>{number}</h1>
            {
                (() => {
                    if(loading)
                        return (<h2>로딩중...</h2>);
                    if(error)
                        return (<h2>오류 발생!</h2>);
                    return (
                        <div>
                            <h2>{post.title}</h2>
                            <p>{post.body}</p>
                        </div>
                    )
                })()
            }
            <button onClick={CounterActions.increment}>+</button>
            <button onClick={CounterActions.decrement}>-</button>
        </div>
    )
}
```

삼항 연산자가 여러 번 겹칠 때는 이처럼 아에 함수를 만들어서 if문을 사용하는 것이 가독성이 높습니다.


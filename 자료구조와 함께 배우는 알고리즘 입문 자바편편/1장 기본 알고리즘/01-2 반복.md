# 01-2 반복

## 1부터 n까지의 정수 합 구하기

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.println("1부터 n 까지의 합을 구합니다.");
        System.out.print("n의 값: ");
        int n = stdIn.nextInt();

        int sum = 0;
        int i = 1;
        while (i <= n) {
            sum += i;
            i++;
        }
        System.out.printf("1부터 %d 까지의 합은 %d 입니다.",n, sum);
    }
}
```

### while 반복

어떤 조건이 성립하는 동안 처리를 반복하여 실행하는 것을 반복 구조라 하면 일반적으로 루프라고 부릅니다.

### for문 반복

하나의 변수를 사용하는 반복문은 while문 보다 for문을 사용하는 것이 좋습니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.println("1부터 n 까지의 합을 구합니다.");
        System.out.print("n의 값: ");
        int n = stdIn.nextInt();

        int sum = 0;

        for (int i = 0; i <= n ; i++) {
            sum += i;
        }
        System.out.printf("1부터 %d 까지의 합은 %d 입니다.",n, sum);
    }
}
```

## 양수만 입력하기

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        int n;

        System.out.println("1부터 n까지의 합을 구합니다.");

        do {
            System.out.print("n의 값: ");
            n = stdIn.nextInt();
        } while (n <= 0);

        int sum = 0;

        for (int i = 0; i <= n ; i++) {
            sum += i;
        }

        System.out.printf("1부터 %d 까지의 합은 %d 입니다.", n, sum);
    }
}
```

do문은 일단 루프 본문을 한 번 실행한 다음에 계속 반복할 것인지를 판단하는 사후 판단 반복문입니다.

### 사전 판단 반복과 사후 판단 반복의 차이점

사전 판단 반복문인 while문과 for문은 처음에 제이식을 평가한 결과가 0이면 루프 본문은 한 번도 실행되지 않습니다.

이와 달리 사후 판단 반복문인 do문은 루프 본문이 반드시 한 번은 실행됩니다.

## 구조적 프로그래밍

하나의 입구와 하나의 출구를 가진 구성 요소만을 계층적으로 배치하여 프로그램을 구성하는 방법을 구조적 프로그래밍이라고 합니다.

구조적 프로그래밍은 순차, 선택, 반복이라는 3종류의 제어 흐름을 사용합니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        int no;

        System.out.println("2자리의 정수를 입력하세요.");

        do {
            System.out.print("입력: ");
            no = stdIn.nextInt();
        } while (no < 10 || no > 99);

        System.out.printf("변수 no의 값은 %d 가 되었습니다.",no);
    }
}
```

### 논리 연산자의 단축 평가

no에 입력한 값이 5인 경우 식 no < 10 의 평가값이 true이므로 오른쪽 피연산자 no > 99를 평가하지 않아도 제어식 no < 10 || no > 99의 값이 true가 됩니다.

왼쪽 피연산자 x 와 오른쪽 피연산자 y 중 어느 하나라도 true라면 논리식 x || y의 값은 true가 되기 때문입니다. 그러므로 || 연산자의 왼쪽 피연산자를 평가한 값이 true면 오른쪽 피연산자는 평가하지 않습니다.

마찬가지로 && 연산자의 경우 왼쪽 피연산자를 평가한 값이 false면 오른쪽 피연산자는 평가하지 않습니다.

이처럼 논리 연산의 식 전체를 평가한 결과가 왼쪽 피연산자의 평가 결과만으로 정확해지는 경우 오른쪽 피연산자의 평가를 수행하지 않는데, 이를 단축 평가라고 합니다.

### 드모르간 법칙

`각 조건을 부정하고 논리곱을 논리합으로, 논리합을 논리곱으로 바꾸고 다시 전체를 부정하면 원래의 조건과 같다`라는 법칙을 드모르간 법칙이라고 합니다.

> x && y 와 !(!x || !y)는 같습니다.
> x || y와 !(!x && !y)는 같습니다.

## 다중 루프

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        System.out.println("-----곱셈표-----");
        for (int i = 1; i <= 9 ; i++) {
            for (int j = 1; j <= 9 ; j++) {
                System.out.printf("%3d", i * j);
            }
            System.out.println();
        }
    }
}
```

## 직각 이등변 삼각형 출력

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        int n;

        System.out.println("왼쪽 아래가 직각인 이등변 삼각형을 출력합니다.");

        do {
            System.out.println("몇 단 삼각형입니까?: ");
            n = stdIn.nextInt();
        } while (n <= 0);

        for (int i = 1; i <=n ; i++) {
            for (int j = 1; j <= i ; j++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
```

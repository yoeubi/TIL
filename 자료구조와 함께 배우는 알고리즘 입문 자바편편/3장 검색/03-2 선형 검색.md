# 03-2 선형 검색

## 선형 검색

요소가 직선 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하면 되는데, 이것이 선형 검색(linear search) 또는 순처 검색(seqeuntial search)이라는 알고리즘입니다.

다음 조건중 하나라도 성립하면 검색을 종료합니다.

1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
1. 검색할 값과 같은 요소를 발견한 경우

조건 1이 성립하면 검색 실패, 조건 2가 성립하면 검색 성공입니다.

배열의 요소수가 n개 일 때 조건 1,2를 판단하는 횟수는 평균 n / 2 회입니다.

```java
import java.util.Scanner;

class Main {
    static int seqSearch(int[] a, int n , int key) {
        int i = 0;

        while (true) {
            if (i == n) {
                return -1;
            }
            if (a[i] == key) {
                return i;
            }
            i++;
        }
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("요소수: ");
        int num = stdIn.nextInt();
        int[] x = new int[num];

        for (int i = 0; i < num ; i++) {
            System.out.printf("x[%d]: ", i);
            x[i] = stdIn.nextInt();
        }

        System.out.print("검색할 값: ");
        int key = stdIn.nextInt();

        int idx = seqSearch(x,num,key);

        if(idx == -1) {
            System.out.println("그 값의 요소가 없습니다.");
        } else {
            System.out.printf("%d는 x[%d]에 있습니다.",key,idx);
        }
    }
}
```

메서드 seqSearch는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이 key인 요소를 선형 검색하고 검색한 요소의 인덱스를 반환합니다.

또한 값이 key인 요소가 여러 개 존재할 경우 반환값은 검색 과정에서 처음 발견한 요소의 인덱스가 됩니다.

값이 key인 요소가 존재하지 않으면 -1을 반환합니다.

배열을 검색할때 배열 요소의 인덱스를 가리키는 변수는 i입니다. i는 0으로 초기화하고 요소를 하나 검색할 때마다 while문이 제어하는 루프 본문의 끝에서 증가시킵니다.

while문을 빠져나가는 경우는 앞에서 살펴본 종료 조건 가운데 하나가 성립한 경우입니다.

1. i == n이 성립하는 경우 (검색 실패 이므로 -1을 반환)
1. `a[i]` == key가 성립하는 경우 (검색 성공이므로 i를 반환)

배열 검색을 while문이 아니라 for문으로 구현하면 프로그램은 보다 짧고 간결해집니다.

```java
static int seqSearch(int[] a, int n, int key) {
    for (int i = 0; i < n; i++){
        if(a[i] == key){
            return i;
        }
    }
    return -1;
}
```

## 보초법

선형 검색은 반복할때 마다 다음 종료 조건 1과 2를 모두 판단합니다. 단순한 판단이라고 생각할 수 있지만 티클 모아 태산이라는 말이 있듯이 종료 조건을 검사하는 비용은 결코 무시할 수 없습니다.

1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
1. 검색할 값과 같은 요솔르 발견한 경우

이 비용을 반으로 줄이는 방법이 보초법(sentinel method)입니다.

검색하기 전에 검색하고자 하는 키 값을 맨 끝 요소 `a[7]`에 저장합니다. 이 때 저장하는 값을 보초라고 합니다.

1. 2를 검색하기 위해 보초로 `a[7]`에 2를 저장합니다.
1. 5를 검색하기 위해 보초로 `a[7]`에 5를 저장합니다.

이렇게 하면 원하는 키 값을 찾지 못했을 때를 판단하는 종료 조건 1이 없어도 됩니다.

보초는 반복문에서 종료 판단 횟수를 2회에서 1회를 줄이는 역활을 합니다.

```java
import java.util.Scanner;

class Main {
    static int seqSearch(int[] a, int n , int key) {
        int i = 0;
        a[n] = key;

        while (true) {
            if (a[i] == key) {
                break;
            }
            i++;
        }
        return i == n ? -1 : i;
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("요소수: ");
        int num = stdIn.nextInt();
        int[] x = new int[num + 1];

        for (int i = 0; i < num ; i++) {
            System.out.printf("x[%d]: ", i);
            x[i] = stdIn.nextInt();
        }

        System.out.print("검색할 값: ");
        int key = stdIn.nextInt();

        int idx = seqSearch(x,num,key);

        if(idx == -1) {
            System.out.println("그 값의 요소가 없습니다.");
        } else {
            System.out.printf("%d는 x[%d]에 있습니다.",key,idx);
        }
    }
}
```

1. 검색할 값 key를 보초로 `a[n]`에 대입합니다.
1. 배열의 요소를 순서대로 검사합니다. 앞서 while문에는 다음과 같은 if문이 2개 있었습니다.
    1. if(i == n) // 종료 조건 1
    1. if(`a[i]` == key) // 종료 조건 2
       이 프로그램은 종료 조건 1이 필요하지 않기 때문에 하나의 if문만 사용했습니다. 따라서 반복 종료에 대한 판단 횟수는 실제로 절반으로 줄어듭니다.
1. while문에 의한 반복이 완료되면 찾은 값이 배열의 원래 데이터인지 아니면 보초인지 판단해야 합니다. 변수 i 값이 n이면 찾은 값이 보초이므로 검색 실패를 나타내는 -1을 반환합니다.

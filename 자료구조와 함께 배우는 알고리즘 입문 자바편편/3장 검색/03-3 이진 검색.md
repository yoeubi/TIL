# 03-3 이진 검색

이 알고리즘을 적용하는 전체 조건은 데이터가 키 값으로 이미 정렬되어 있다는 것입니다.

이진 검색은 선형 검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있습니다.

## 이진 검색

이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘입니다.

이러한 n개의 요소가 오름차순으로 늘어선 배열 a에서 키를 이진 검색으로 검색하는 과정을 일반적인 방법으로 표현해 보겠습니다.

이때 검색 범위의 맨 앞 인덱스를 pl, 맨 끝 인덱스를 pr, 중앙 인덱스를 pc라고 지정합니다.

검색을 시작할 때 pl은 0, pr은 n - 1, pc는 (n - 1)/2로 초기화합니다.

이진 검색을 한 단계씩 진행ㅎㄹ 때마다 검색 범위가 반으로 좁혀진다는 것입니다.

또한 검사한 요소를 하나씩 제외시키는 선형 검색과는 다르게 이진 검색은 검색할 요소가 해당 단계에서 다음에 검색할 범위의 중간 지점을 단숨에 이동합니다.

`a[pc]`와 key를 비교하여 같으면 검색 성공입니다. 하지만 원하는 값을 찾지 못하면 아래와 같은 방법으로검색 범위를 좁혀 갈수 있습니다.

1. `a[pc] < key` 일때

`a[pl]` ~ `a[pc]`는 key보다 작은 것이 분명하므로 검색 대상에서 제외합니다.

검색 범위는 중앙요소 `a[pc]`보다 뒤쪽의 `a[pc + 1] ~ a[pr]`로 좁힙니다. 그런 다음 pl의 값을 pc + 1로 업데이트 합니다.

2. `a[pc] > key` 일 때

a[pc] ~ a[pr]은 key보다 큰 것이 분명하므로 검색 대상에서 제외합니다.

검색 범위는 중앙요소 `a[pc]`보다 앞쪽 `a[pl] ~ a[pc - 1]`로 좁힙니다. 그런 다음 pr의 값을 pc - 1로 업데이트 합니다.

이진 검색 알고리즘의 종료 조건은 아래 조건 1,2 중 하나만 성립하면 됩니다.

1. `a[pc]`와 key가 일차하는 경우
1. 검색 범위가 더 이상 없는 경우

이진 검색은 검색을 반복할 때마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n 입니다.

이진 검색 알고리즘은 검색 대상이 정렬되어 있음을 가정합니다.

```java
import java.util.Scanner;

class Main {
    static int binSearch(int[] a, int n, int key) {
        int pl = 0;
        int pr = n - 1;

        do {
            int pc = (pl + pr) / 2;
            if(a[pc] == key){
                return pc;
            } else if(a[pc] < key) {
                pl = pc + 1;
            } else {
                pr = pc - 1;
            }
        } while (pl <= pr);
        return -1;
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("요소수: ");
        int num = stdIn.nextInt();
        int[] x = new int[num];

        System.out.println("오름차순으로 입력하세요");
        System.out.print("x[0]: ");
        x[0] = stdIn.nextInt();

        for (int i = 1; i < num ; i++) {
            do {
                System.out.printf("x[%d]: ",i);
                x[i] = stdIn.nextInt();
            } while (x[i] < x[i - 1]);
        }

        System.out.print("검색할 값: ");
        int key = stdIn.nextInt();


        int idx = binSearch(x,num,key);

        if(idx == -1){
            System.out.println("그 값의 요소가 없습니다.");
        } else {
            System.out.printf("%d는 x[%d]에 있습니다.",key,idx);
        }
    }
}
```

## 복잡도

1. 시간 복잡도: 실행에 필요한 시간을 평가한 것
1. 공간 복잡도: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것

### 선형 검색의 시간 복잡도

```java
static int seqSearch(int[] a, int n, int key) {
    int i = 0;
    while(i < n) {
        if(a[i] == key) {
            return il
        }
        i++;
    }
    return -1;
}
```

변수 i에 0을 대입하는 횟수는 처음 한번 실행한 이후에는 없습니다.

이렇게 한번만 실행하는 경우 복잡도는 O(1)로 표기합니다.

배열의 맨 끝에 도달했는지를 판단하는 while문과 현재 검사하고 있는 요소와 찾고자 하는 값이 같은지를 판단하는 if문의 평균 실행 횟수는 n / 2 입니다.

이 처럼 n에 비례하는 횟수만큼 실행하는 경우의 복잡도를 O(n)으로 표기합니다.

일반적으로 O(f(n))과 O(g(n))의 복잡도를 계산하는 방법은 아래와 같습니다.

> O(f(n)) + O(g(n)) = O(max(f(n), g(n)))

다시 말해 복잡도는 차원이 가장 높은 복잡도를 선택합니다.

그러므로 선형 검색 알고리즘의 복잡도를 구하면 아래처럼 O(n)이 됩니다.

> O(1) + O(n) + O(n) + O(1) + O(n) + O(1) = O(max(1,n,n,1,n,1)) = O(n)

### 이진 검색의 시간 복잡도

> O(1) + O(1) + O(log n) + O(log n) + O(1) + O(log n) + .... + O(1) = O(log n)

## Arrays.binarySearch에 의한 이진 검색

binarySearch 메서드는 다음과 같은 장점이 있습니다.

1. 이진 검색 메서드를 직접 코딩할 필요가 없다.
1. 모든 자료형 배열에서 검색할 수 있다.

### 검색에 성공한 경우

key와 일치하는 요소의 인덱스를 반환합니다. 일치하는 요소가 여러 개 있다면 무작위의 인덱스를 반환합니다. 맨 앞의 인덱스나 어떤 특정한 인덱스를 반환하는 것이 아닙니다.

### 검색에 실패한 경우

반환값은 삽입 포인트를 x라고 할 때 -x - 1을 반환합니다. 삽입 포인트는 검색하기 위해 지정한 key보다 큰 요소 중 첫 번째 요소의 인덱스입니다.

만약 배열의 모든 요소가 key보다 작다면 배열의 길이를 삽입 포인트로 정합니다.

### 기본 자료형 배열에서 binarySearch 메서드로 검색하기

```java
import java.util.Arrays;
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("요소수: ");
        int num = stdIn.nextInt();
        int[] x = new int[num];

        System.out.println("오름차순으로 입력하세요");
        System.out.print("x[0]: ");
        x[0] = stdIn.nextInt();

        for (int i = 1; i < num ; i++) {
            do {
                System.out.printf("x[%d]: ",i);
                x[i] = stdIn.nextInt();
            } while (x[i] < x[i - 1]);
        }

        System.out.print("검색할 값: ");
        int key = stdIn.nextInt();

        int idx = Arrays.binarySearch(x,key);

        if(idx == -1){
            System.out.println("그 값의 요소가 없습니다.");
        } else {
            System.out.printf("%d는 x[%d]에 있습니다.",key,idx);
        }
    }
}
```

### 객체의 배열에서 검색하기

1. static int binarySearch(Object[] a, Object key)
   자연 정렬이라는 방법으로 요소의 대소 관계를 판단합니다. 따라서 정수 배열, 문자열 배열에서 검색할 때 적당합니다.
1. static <T> int binarySearch(T[] a, T key, Comparator<? super T> c)
   자연 순서가 아닌 순서로 줄지어 있는 배열에서 검색하거나 자연 순서를 논리적으로 갖지 않는 클래스 배열에서 검색할때 알맞습니다.

#### 자연 정렬로 정렬된 배열에서 검색하기

문자열 key에 입력하고 배열 x와 키 값 key를 binarySearch메서드에 전달하면 검색할 수 있습니다.

```java
import java.util.Arrays;
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        String[] x = {
                "abstract", "assert", "boolean"
        };

        System.out.print("원하는 키워드를 입력하세요: ");
        String key = stdIn.next();

        int idx = Arrays.binarySearch(x,key);

        if(idx < 0){
            System.out.println("그 값의 요소가 없습니다.");
        } else {
            System.out.printf("%s는 x[%d]에 있습니다.",key,idx);
        }
    }
}
```

##### 자연 정렬

binarySearch 메서드에 배열과 키 값을 전달하는 간단한 방법을 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스와 compareTo 메서드를 구현하고 있기 때문입니다.

```java
class A implements Comparable<A> {
    public int compareTo(A c) {
        // this가 c보다 크면 양의 값 반환
        // this가 c보다 작으면 음의 값 반환
        // this가 c와 같다면 0 반환
    }
    public boolean equals(Object c) {
        // this가 c와 같으면 true 반환
        // this가 c와 같지 않으면 false 반환
    }
}
```

#### 자연 정렬로 정렬되지 않은 배열에서 검색하기

자연 정렬로 정렬되지 않은 배열에서의 검색은 제너릭 메서드로 하면 됩니다.

제네릭 메서드의 첫 번째 매개변수는 a는 검색 대상이고, 두 번쨰 매개변수 key는 키 값입니다.

하지만 배열의 요소가 어떤 순서로 줄지어 있는지, 각 요소의 대소 관계를 어떻게 판단할 것인지에 대해서는 binarySearch 메서드에 알려주어야 합니다.

이 정보는 세 번째 매개변수 c에 전달합니다.

세 번쨰 매개변수 c에는 comparator를 전달합니다. comparator의 근원은 다음과 같이 정의된 java.util.Comparator 인터페이스입니다.

```java
package java.util;

public interface Comparator <T> {
    int compare(T o1, T o2);
    boolean equals(Object obj);
}
```

객체의 대소 관계를 판단하는 comparator를 직접 구현하려면 Comparator 인터페이스를 구현한 클래스를 정의하고 그 클래스형의 인스턴스를 생성해야 합니다.

그런 다음 매개변수로 전달된 두 객체의 대소 관계를 비교하여 그 결과를 다음과 같이 반환하는 compare 메서드를 구현하면 됩니다.

```java
public int compare(T d1, T d2) {
    if(d1 > d2) return 양수;
    if(d1 < d2) return 음수;
    if(d1 == d2) return 0;
}
```

```java
class X {
    public static final Comparator<T> COMPARATOR = new Comp();

    private static class Comp implements Comparator<T> {
        public int compare(T d1, T d2) {
            // d1이 d2보다 크면 양의 값 반환
            // d1이 d2보다 작으면 음의 값 반환
            // d1이 d2와 같으면 0 반환
        }
    }
}
```

binarySearch 메서드의 세 번째 매개변수로 클래스 x의 클래스 변수인 x.COMPARATOR를 전달하면 됩니다.

호출된 binarySearch 메서드는 전달받은 comparator를 기준으로 배열 요소의 대소 관계를 판단하여 이진 검색을 수행합니다.

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

class Main {
    static class PhysData {
        private String name;
        private  int height;
        private double vision;

        public PhysData(String name, int height, double vision) {
            this.name = name;
            this.height = height;
            this.vision = vision;
        }

        public String toString() {
            return name+ " " + height + " " + vision;
        }

        public static final Comparator<PhysData> HEIGHT_ORDER = new HeightOrderComparator();

        private static class HeightOrderComparator implements Comparator<PhysData> {
            @Override
            public int compare(PhysData o1, PhysData o2) {
                return (o1.height > o2.height) ? 1 :
                        (o1.height < o2.height) ? -1 : 0;
            }
        }
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        PhysData[] x = {
                new PhysData("이나령", 162,0.3),
                new PhysData("유지훈", 168,0.4),
                new PhysData("김한결", 169,0.8),
        };
        System.out.print("몇 cm인 사람을 찾고 있나요?");
        int height = stdIn.nextInt();
        int idx = Arrays.binarySearch(x,new PhysData("", height, 0.0), PhysData.HEIGHT_ORDER);

        if(idx < 0) {
            System.out.println("요소가 없습니다.");
        } else {
            System.out.printf("x[%d]에 있습니다.",idx);
            System.out.printf("찾은데이터: %s", x[idx] );
        }
    }
}
```

# 02-1 배열

## 자료구조

자료구조는 다음과 같이 정의할 수 있습니다.

> 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계

> 데이터 단위는 데이터를 구성하는 한 덩어리라고 생각하면 됩니다. 그리고 자료구조는 쉽게 말해 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법을 말합니다.

## 배열

배열은 같은 자료형의 변수로 이루어진 구성 요소가 모인 것입니다.

new 연산자가 생성하는 것은 배열 본체에 대한 참조입니다. 참조하는 곳이 a에 대입되고 그 결과 배열 변수 a가 배열 본체를 참조하게 됩니다.

### 구성요소

배열 안의 모든 구성 요소의 형은 같고 직선 모양으로 줄지어 있습니다.

이러한 배열의 개별 요소에 접근하기 위해 사용하는 것이 연산자 []안에 넣는 정수형 인덱스입니다.

다시 말해 표현식 `a[i]`는 배열 a에서 처음부터 i개 뒤의 구성 요소에 접근합니다.

### 구성요소수(길이)

배열 본체와 함께 구성 요소의 개수인 구성 요소수를 나타내는 length라는 변수가 만들어집니다.

또 배열의 구성 요소수는 배열의 길이(length)라고도 합니다.

### 기본값

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int[] a = new int[5];

        a[1] = 37;
        a[2] = 51;
        a[4] = a[1] * 2;

        for (int i = 0; i < a.length ; i++) {
            System.out.printf("a[%d] = %d", i, a[i]);
            System.out.println();
        }
    }
}
```

배열을 생성할 때 각 구성 요소에 넣어지는 값을 초기값이라고 합니다.

| 형      | 초기값              |
| :------ | :------------------ |
| byte    | (byte) 0            |
| short   | (short) 0           |
| int     | 0                   |
| long    | 0L                  |
| float   | 0.0f                |
| double  | 0.0d                |
| char    | \u0000              |
| boolean | false               |
| 참조형  | 공백 참조 또는 null |

#### 값을 대입하지 않은 지역 변수

메서드 안에서 선언한 지역 변수는 초기값으로 초기화되지 않습니다.

### 배열의 요소값을 초기화하며 배열 선언하기

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int[] a = {1,2,3,4,5};

        for (int i = 0; i < a.length ; i++) {
            System.out.printf("a[%d] = %d",i,a[i]);
            System.out.println();
        }
    }
}
```

### 배열의 복제(클론)

> 배열 이름.clone()

이 수식은 배열을 복제하고 복제한 배열에 대한 참조를 생성합니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int[] a = {1,2,3,4,5};
        int[] b = a.clone();

        b[3] = 0;

        System.out.println("a = ");

        for (int i = 0; i < a.length ; i++) {
            System.out.printf("a[%d] = %d",i,a[i]);
            System.out.println();
        }

        System.out.println("b =");
        for (int i = 0; i < b.length ; i++) {
            System.out.printf("b[%d] = %d",i,b[i]);
            System.out.println();
        }
    }
}
```

## 배열 요소의 최대값 구하기

먼저 배열의 요소 개수와 관계없이 첫 번쨰 요소 `a[0]`의 값을 max에 대입합니다. 그런 다음 if문을 실행하는 과정에서 필요에 따라 max 값을 새로 대입합니다.

요소 개수가 n이면 if실행은 n - 1번 필요합니다.

이 처럼 배열의 요소를 하나씩 차례로 살펴보는 과정을 알고리즘 용어로 스캔(traverse)이라고 합니다.

### 배열 요소의 최대값 구하는 메서드

```java
import java.util.Scanner;

class Main {

    public static int maxOf(int[] a) {
        int max = a[0];
        for (int i = 0; i < a.length; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }
        return max;
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        System.out.println("키의 최대값을 구합니다.");
        System.out.print("사람 수: ");
        int num = stdIn.nextInt();

        int[] height = new int[num];

        for (int i = 0; i < num ; i++) {
            System.out.printf("height[%d]",i);
            height[i] = stdIn.nextInt();
        }

        System.out.printf("최대값은 %d 입니다.", maxOf(height));
    }
}
```

### 난수 사용해 배열의 요소값 설정하기

```java
import java.util.Random;
import java.util.Scanner;

class Main {

    public static int maxOf(int[] a) {
        int max = a[0];
        for (int i = 0; i < a.length; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }
        return max;
    }

    public static void main(String[] args) {
        Random rand = new Random();
        Scanner stdIn = new Scanner(System.in);
        System.out.println("키의 최대값을 구합니다.");
        System.out.print("사람 수: ");
        int num = stdIn.nextInt();

        int[] height = new int[num];

        for (int i = 0; i < num ; i++) {
            height[i] = 100 + rand.nextInt(90);
            System.out.printf("height[%d]: %d",i,height[i]);
            System.out.println();
        }

        System.out.printf("최대값은 %d 입니다.", maxOf(height));
    }
}
```

rand.nextInt(n)가 반환하는 것은 0부터 n - 1 까지의 난수입니다.

## 배열 요소를 역순으로 정렬하기

교환 횟수는 `요소 개수/2`이며, 이 나눗셈에서 나머지는 버립니다. 요소 개수가 홀수인 경우 가운데 요소는 교환할 필요가 없기 때문입니다.

### 두 값의 교환

> `t = a[idx1]` > `a[idx1] = a[idx2]` > `a[idx2] = t`

```java
import java.util.Random;
import java.util.Scanner;

class Main {
    static void swap(int[] a, int idx1, int idx2) {
        int t = a[idx1];
        a[idx1] = a[idx2];
        a[idx2] = t;
    }

    static  void reverse(int[] a) {
        for (int i = 0; i < a.length / 2 ; i++) {
            swap(a,i,a.length - 1 - i);
        }
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("요소수: ");
        int num = stdIn.nextInt();

        int[] x = new int[num];

        for (int i = 0; i < num ; i++) {
            System.out.printf("x[%d]: ", i);
            x[i] = stdIn.nextInt();
        }
        reverse(x);

        System.out.println("요소를 역순으로 정렬했습니다.");
        for (int i = 0; i < num ; i++) {
            System.out.printf("x[%d] = %d", i, x[i]);
            System.out.println();
        }
    }
}
```

## 두 배열의 비교

```java
import java.util.Random;
import java.util.Scanner;

class Main {
    static boolean equals(int[] a, int[] b) {
        if(a.length != b.length){
            return false;
        }
        for (int i = 0; i < a.length ; i++) {
            if(a[i] != b[i]){
                return  false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("배열 a의 요소수: ");
        int na = stdIn.nextInt();

        int[] a = new int[na];

        for (int i = 0; i < na ; i++) {
            System.out.printf("a[%d]:", i);
            a[i] = stdIn.nextInt();
        }
        System.out.print("배열 b의 요소수:");

        int nb = stdIn.nextInt();

        int[] b = new int[nb];

        for (int i = 0; i < nb ; i++) {
            System.out.printf("b[%d]:", i);
            b[i] = stdIn.nextInt();
        }

        System.out.printf("배열 a와 b는 %s", (equals(a,b)?"같습니다.":"같지 않습니다."));
    }
}
```

## 기수 변환

10진수 정수를 n진수 정소로 변환하려면 정수를 n으로 나눈 나머지를 구하는 동시에 그 몫에 대해 나눗셈을 반복해야 합니다.

이 과정을 몫이 0이 될때까지 반복하고, 이런 과정으로 구한 나머지를 거꾸로 놓은 숫자가 기수로 변환한 숫자입니다.

```java
class Main {
    static int cardConvR(int x, int r, char[] d) {
        int digits = 0;
        String dchar = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        do {
            d[digits++] = dchar.charAt(x % r);
            x /= r;
        } while (x != 0);
        return digits;
    }
}
```

```java
import java.util.Scanner;

class Main {
    static int cardConvR(int x, int r, char[] d) {
        int digits = 0;
        String dchar = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        do {
            d[digits++] = dchar.charAt(x % r);
            x /= r;
        } while (x != 0);
        return digits;
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        int no;
        int cd;
        int dno;
        int retry;
        char[] cno = new char[32];

        System.out.println("10진수를 기수변환합니다.");
        do {
            do {
                System.out.print("변환하는 음이 아닌 정수:");
                no = stdIn.nextInt();
            } while (no < 0);

            do {
                System.out.print("어떤 진수로 변환할까요? (2~36): ");
                cd = stdIn.nextInt();
            } while (cd < 2 || cd > 36);

            dno = cardConvR(no,cd,cno);
            System.out.print("%d 진수로는 ");
            for (int i = dno - 1; i >= 0; i--) {
                System.out.print(cno[i]);
            }
            System.out.println("입니다.");
            System.out.print("한 번 더 할까요? (1. 예 / 0. 아니요) : ");
            retry = stdIn.nextInt();
        } while (retry == 1);
    }
}
```

## 소수의 나열

소수는 자신과 1 이외의 정소로 나누어떨어지지 않는 정수입니다.

예를 들어 소수인 13은 2,3, ... , 12 가운데 어떤 수로도 나누어떨어지지 않습니다.

그러므로 어떤 정수 n에 대하여 아래의 조건을 만족하면 소수임을 알 수 있습니다.

> 2부터 n - 1 까지의 어떤 정수로도 나누어 떨어지지 않습니다.

만약 나누어 떨어지는 정수가 아나 이상 존재하면 그 수는 합성수 입니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int counter = 0;

        for (int n = 2; n <= 1000 ; n++) {
            int i;
            for (i = 2; i < n ; i++) {
                counter++;
                if(n % i == 0) {
                    break;
                }
            }
            if(n == i){
                System.out.println(n);
            }
        }
        System.out.printf("나눗셈을 수행한 횟수: %d",counter);
    }
}
```

### 9일 때 소수인지 판단하는 방법

안쪽의 for문에서 i 값을 2,3, ... , 8로 증가합니다. 9는 i가 3일때 나누어 떨어지므로 break문이 동작하여 for문의 반복이 중단됩니다.

따라서 나누셈은 2,3 2회만 진행됩니다. for문을 벗어날 때의 i값은 3입니다.

### 13일 때 소수인지 판단하는 방법

안쪽의 for문에서 i값을 2,3, ... , 12로 증가합니다. 13은 한 번도 나누어 떨어지지 않습니다.

따라서 11회의 나눗셈이 모두 수행됩니다. for문을 벗어날 때의 i값은 13입니다.

그런데 n이 2 또는 3으로 나누어떨어지지 않는다면 2 x 2 인 4 또는 2 x 3인 6으로도 나누어떨어지지 않습니다.

그러므로 이 프로그램은 불필요한 나눗셈을 하고 있음을 알 수 있습니다.

즉, 정수 n이 소수인지의 여부는 아래 조건을 만족하는지 조사하면 됩니다.

> 2부터 n - 1 까지의 어떤 소수로도 나누어떨어지지 않습니다.

예를 들어 7이 소수인지는 7보다 작은 소수 2,3,5로 나눗셈을 하면 충분합니다.

### 알고리즘 개선(1)

소수를 구하는 과정에서 그 때까지 구한 소수를 배열 prime의 요소로 저장합니다.

이 떄 n이 소수인지 아닌지 판단하기 위해서는 쌓아두었던 소수에서 나누셈을 진행합니다.

먼저 2는 소수이므로 `prime[0]`에 저장합니다. `prime[0]`에 2를 저장한 바로 다으미의 ptr 값은 1입니다.

3 이상의 소수는 이중 for문으로 구합니다. 바깥쪽 for문은 n의 값을 2씩 증가하여 3,5,7,9, .... , 999로 홀수 값만을 생성합니다.

4 이상의 짝수는 2로 나누어 떨어지므로 소수가 아니기 때문입니다.

안쪽의 for문은 i 값을 1부터 시작하여 ptr - 1 회 반복합니다.

#### 3이 소수인지 판단하는 과정(n은 3)

안쪽 for문은 실행되지 않고 if문에 의해 n값 3이 `prime[1]`에 저장됩니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int counter = 0;
        int ptr = 0;
        int[] prime = new int[500];

        prime[ptr++] = 2;

        for (int n = 3; n <= 1000 ; n+=2) {
            int i;
            for (i = 1; i < ptr; i++) {
                counter++;
                if(n % prime[i] == 0) {
                    break;
                }
            }
            if(ptr == i){
                prime[ptr++] = n;
            }
        }
        for (int i = 0; i < ptr ; i++) {
            System.out.println(prime[i]);
        }
        System.out.printf("나눗셈을 수행한 횟수: %d",counter);
    }
}
```

#### 5가 소수인지 판단하는 과정

`prime[1]`에 저장한 3으로 나눗셈을 합니다. 3으로 나누어 떨어지지 않기 때문에 n의 값 5를 `prime[2]`에 저장합니다.

#### 7이 소수인지 판단하는 과정

`prime[1]`에 저장한 3과 `prime[2]`에 저장한 5로 나눗셈을 합니다. 소수라고 판단되므로 n의 값 7을 `prime[3]`에 저장합니다.

#### 9가 소수인지 판단하는 과정

`prime[1]`에 저장한 3으로 나눗셈을 합니다. 3으로 나누어 떨어지므로 소수가아닌 합성수라고 판단합니다.

### 알고리즘 개선(2)

모든 직사각형은 정사각형인 10 x 10 을 중심을 대칭 형태를 이루고 있습니다. 이는 정사각형 한 변의 길이까지만 소수로 나눗셈을 시도하고, 그 과정에서 한 번도 나누어 떨어지지 않으면 소수라고 판단해도 좋다는 것을 의미합니다.

즉, 어떤 정수 n은 다음 조건을 만족하면 소수라고 판단할 수 있습니다.

> n의 제곱근 이하의 어떤 소수로도 나누어 떨어지지 않습니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int counter = 0;
        int ptr = 0;
        int[] prime = new int[500];

        prime[ptr++] = 2;
        prime[ptr++] = 3;

        for (int n = 5; n <= 1000 ; n+=2) {
            boolean flag = false;
            for (int i = 1; prime[i] * prime[i] <= n ; i++) {
                counter += 2;
                if(n % prime[i] == 0) {
                    flag = true;
                    break;
                }
            }
            if(!flag){
                prime[ptr++] = n;
                counter++;
            }
        }
        for (int i = 0; i < ptr ; i++) {
            System.out.println(prime[i]);
        }
        System.out.printf("나눗셈을 수행한 횟수: %d",counter);
    }
}
```

## 다차원 배열

배열을 구성 요소로 하는 것이 2차원 배열이며, 2차원 배열을 구성 요소로 하는 것이 3차원 배열입니다.

Java는 엄밀한 의미에서 다차원 배열이 없습니다. 왜냐하면 2차원 배열을 `배열의 배열`로 생각하고 3차원 배열을 `배열의 배열의 배열`로 생각하기 때문입니다.

따라서 배열 x의 형은 아래와 같습니다.

> `int형을 구성 자료형으로 하는 배열`을 구성 자료형으로 하는 배열

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        int[][] x = new int[2][4];

        x[0][1] = 37;
        x[0][3] = 54;
        x[1][2] = 65;

        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 4; j++) {
                System.out.printf("x[%d][%d] = %d",i,j,x[i][j]);
                System.out.println();
            }
        }
    }
}
```

## 한 해의 경과 일 수를 계산하는 프로그램

2차원 배열을 활용하여 어떤 날짜의 `그 해의 경과 일 수`를 구해 보겠습니다.

일반적으로 나타내면 m월 d일의 그 해 경과 일 수는 다음과 같습니다.

> 1월, 2월, .... , m - 1월의 일 수의 합 + d

그런데 2월의 일 수는 평년의 28일, 윤년은 29일로 해에 따라 달라집니다. 그래서 아래처럼 2행 12열의 2차원 배열 mdays에 각 달의 일 수를 저장할 수 있습니다.

> 평년의 각 달의 일 수 `mdays[0][0]`, `mdays[0][1]`, ...., `mdays[0][11]`
> 윤년의 각 달의 일 수 `mdays[1][0]`, `mdays[1][1]`, ...., `mdays[1][11]`

```java
import java.util.Scanner;

class Main {
    static int[][] mdays = {
            {31,28,31,30,31,30,31,31,30,31,30,31},
            {31,29,31,30,31,30,31,31,30,31,30,31}
    };

    static int isLeap(int year){
        return (year % 4 == 0 && year % 100 ==0 || year % 400 == 0)? 1: 0;
    }
    static int dayOfYear(int y, int m , int d) {
        int days = d;
        for (int i = 1; i < m ; i++) {
            days += mdays[isLeap(y)][i - 1];
        }
        return  days;
    }
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        int retry;

        System.out.println("그 해 경과 일수를 구합니다.");

        do {
            System.out.print("년: ");
            int year = stdIn.nextInt();
            System.out.print("월: ");
            int month = stdIn.nextInt();
            System.out.print("일: ");
            int day = stdIn.nextInt();

            System.out.printf("그 해 %d일째 입니다. \n",dayOfYear(year,month,day));

            System.out.print("한 번 더 할까요? (1. 예 / 0. 아니요) : ");
            retry = stdIn.nextInt();
        } while (retry == 1);
    }
}
```

## 다차원 배열의 내부

> `int[][] x = new int[2][4]`

```java
int[][] x;
x = new int[2][4];
x[0] = new int[2];
x[1] = new int[4];
```

1. 2차원 배열 x의 선언입니다. int[][]형의 x는 배열 본체가 아니라 배열 변수입니다.
1. 배열 본체를 생성하고, x가 그걸 참조하도록 대입합니다. 여기서 생성하는 배열은 다음과 같습니다.
    > 구성 자료형이 int[]형이고 구성 요소수가 2인 배열
1. 배열 본체를 생성하고, `x[0]`이 그것을 참조하도록 대입합니다. 여기서 생성하는 배열은 다음과 같습니다.
    > 구성 자료형이 int형이고 구성 요소수가 4인 배열
1. 배열 본체를 생성하고, `x[1]`이 그것을 참조하도록 대입합니다.

행이 다른 요소가 연속으로 놓이지 않는 것에 주의합니다. 예컨대 메모리의 `x[0][3]` 바로 뒤에 `x[1][0]`이 저장되지 않습니다.

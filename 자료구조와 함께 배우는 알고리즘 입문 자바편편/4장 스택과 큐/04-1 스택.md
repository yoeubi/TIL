# 04-1 스택

스택은 데이터를 일시적으로 저장하기 위한 자료구조로, 가장 나중에 넣은 데이터를 가장 먼저 꺼냅니다.

## 스택이란?

스택은 데이터를 일시적으로 저장하기 위해 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출(LIFO, Last In First out)입니다(가장 나중에 넣은 데이터를 가장 먼저 꺼냅니다).

스택에 데이터를 넣는 작업을 푸시(push)라 하고, 스택에서 데이터를 꺼내는 작업을 팝(pop)이라고 합니다.

이렇게 푸시와 팝을 하는 위치를 꼭대기(top)라 하고, 스택의 가장 아랫부분을 바닥(bottom)이라고 합니다.

## 스택 만들기

### 스택 본체용 배열: stk

푸시된 데이터를 저장하는 스택 본체의 배열입니다. 인덱스가 0인 요소가 스택의 바닥(bottom)입니다.

가장 먼저 푸시된 데이터를 저장하는 곳은 `stk[0]`입니다.

### 스택 용량: max

스택의 용량(스택에 쌓을 수 있는 최대 데이터 수)을 나타내는 필드입니다. 이 값은 배열 stk의 요소수와 같습니다.

### 스택 포인터: ptr

스택에 쌓여 있는 데이터 수를 나타내는 필드입니다. 이 값은 스택 포인터라고 합니다.

```java
class Main {
    private int max;
    private int ptr;
    private int[] stk;

    public class EmptyIntStackException extends RuntimeException {
        public EmptyIntStackException() {
        }
    }

    public class OverflowIntStackException extends RuntimeException {
        public OverflowIntStackException() {
        }
    }

    public Main(int capacity) {
        ptr = 0;
        max = capacity;
        try {
            stk = new int[max];
        } catch (OutOfMemoryError e) {
            max = 0;
        }
    }
}
```

스택이 비어 있으면 ptr값은 0이 되고, 가득 차 있으면 max 값과 같습니다.

### 생성자 IntStack

생성자는 스택 본체용 배열을 생성하는 등 준비 작업을 수행합니다. 생성시 스택은 비어 있으므로 스택 포인터 ptr 값을 0으로 합니다.

그리고 매개변수 capacity로 전달받은 값을 스택 용량을 나타내는 max에 복사 하고 요소수가 max인 배열 stk의 본체를 생성합니다.

### 푸시메서드 push

스택에 데이터를 푸시하는 메서드입니다. 스택이 가득 차서 푸시할 수 없는 경우 예외 OverflowStackException을 던집니다.

```java
public int push(int x) throws OverflowIntStackException {
    if(ptr >= max) {
        throw new OverflowIntStackException();
    }
    return stk[ptr++] = x;
}
```

전달받은 데이터 x를 배열 요소 `stk[ptr]`에 저장하고, 스택 포인터를 증가시킵니다. 메서드의 반환값은 푸시한 값입니다.

### 팝 메서드 pop

스택의 꼭대기에서 데이터를 팝(제거)하고 그 값을 반환하는 메서드입니다. 스택이 비어 있어 팝을 할 수 없는 경우 예외 EmptyIntStackException을 던집니다.

```java
public int pop() throws EmptyIntStackException {
    if (ptr <= 0) {
        throw new EmptyIntStackException();
    }
    return stk[--ptr];
}
```

먼저 스택 포인터 ptr의 값을 감소시키고 그때 `stk[ptr]`에 저장되어 있는 값을 반환합니다.

### 피크 메서드 peak

스택의 꼭대기에 있는 데이터를 몰래 엿보는 메서드입니다. 스택이 비어 있는 경우 예외 EmptyIntStackException을 던집니다.

```java
public int peek() throws EmptyIntStackException {
    if (ptr <= 0) {
        throw new EmptyIntStackException();
    }
    return stk[ptr - 1];
}
```

스택이 비어 있지 않으면 꼭대기의 요소 `stk[ptr - 1]`의 값을 반환합니다. 이때 데이터의 입력과 출력이 없으므로 스택 포인터는 변화하지 않습니다.

### 검색 메서드 indexOf

스택 본체의 배열 stk에 x와 같은 값의 데이터가 포함되어 있는지, 포함되어 있다면 배열의 어디에 들어 있는지를 조사하는 메서드입니다.

검색은 꼭대기 쪽에서 바닥 쪽으로 선형 검색을 수행합니다. 즉, 배열 인덱스가 큰 쪽에서 작은 쪽으로 스캔합니다.

검색에 성공하면 찾아낸 요소의 인덱스를 반환하고, 실패하면 -1을 반환합니다.

꼭대기 쪽에서 스캔하는 이유는 먼저 팝이 되는 데이터를 찾기 위해서입니다.

### 스택의 모든 요소를 삭제하는 메서드 clear

clear 메서드는 스택에 쌓여 있는 모든 데이터를 삭제하는 메서드입니다.

### 용량을 확인하는 메서드 capacity

capacity 메서드는 스택의 용량(max의 값)을 반환하는 메서드입니다.

### 데이터 수를 확인하는 메서드 size

size 메서드는 현재 스택에 쌓여 있는 데이터 수(ptr의 값)를 반환하는 메서드입니다.

### 스택이 비어 있는지 검사하는 메서드 IsEmpty

IsEmpty 메서드는 스택이 비어 있는지 검사하는 메서드입니다. 스택이 비어 있으면 true, 그렇지 않으면 false를 반환합니다.

### 스택이 가득 찼는지 검사하는 메서드 IsFull

IsFull 메서드는 스택이 가득 찼는지 검사하는 메서드입니다. 스택이 가득 찼으면 true, 그렇지 않으면 false를 반환합니다.

```java
public int indexOf(int x) {
    for (int i = ptr - 1; i >= 0; i--) {
        if(stk[i] == x) {
            return i;
        }
    }
    return -1;
}

public void clear() {
    ptr = 0;
}

public int capacity() {
    return max;
}

public int size() {
    return ptr;
}

public boolean isEmpty() {
    return ptr <= 0;
}

public boolean isFull() {
    return ptr >= max;
}

public void dump() {
    if(ptr <= 0) {
        System.out.println("스택이 비어 있습니다.");
    } else {
        for (int i = 0; i < ptr ; i++) {
            System.out.print(stk[i] + " ");
        }
        System.out.println();
    }
}
```

### 스택 안에 있는 모든 데이터를 표시하는 메서드 dump

스택에 쌓여 있는 모든 데이터를 바닥에서 꼭대기 순으로 표시하는 메서드입니다.

스택이 비어 있으면 스택이 비어 있습니다 라고 표시합니다.

### 스택을 사용하는 프로그램

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        IntStack s = new IntStack(64);

        while (true) {
            System.out.println("현재 데이터 수:" + s.size() + " / " + s.capacity());
            System.out.print("(1) 푸시 (2) 팝 (3) 피크 (4) 덤프 (0) 종료: ");

            int menu = stdIn.nextInt();
            if (menu == 0) break;

            int x;
            switch (menu) {
                case 1:
                    System.out.print("데이터 : ");
                    x = stdIn.nextInt();
                    try {
                        s.push(x);
                    } catch (IntStack.OverflowIntStackException e) {
                        System.out.println("스택이 가득 찼습니다.");
                    }
                    break;
                case 2:
                    try {
                        x = s.pop();
                        System.out.println("팝한 데이터는 " + x + "입니다.");
                    } catch (IntStack.EmptyIntStackException e) {
                        System.out.println("스택이 비었습니다.");
                    }
                    break;
                case 3:
                    try {
                        x = s.peek();
                        System.out.println("피크한 데이터는 " + x + "입니다.");
                    } catch (IntStack.EmptyIntStackException e) {
                        System.out.println("스택이 비어 있습니다.");
                    }
                    break;
                case 4:
                    s.dump();
                    break;
            }
        }
    }
}
```

# 04-2 큐

## 큐란?

큐(queue)는 스택과 마찬가지로 데이터를 일시적으로 쌓아 두기 위한 자료구조입니다. 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조로 되어 있습니다.

큐에 데이터를 넣는 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 디큐(dequeue)라고 합니다.

또 데이터를 꺼내는 쪽을 프런트(front)라 하고, 데이터를 넣는 쪽을 리어(rear)라고 합니다.

## 배열로 큐 만들기

배열 이름을 que라고 할 경우 `que[0]`부터 `que[3]`까지의 데이터가 저장됩니다.

### 24 인큐

리어(rear)의 데이터가 저장된 `que[3]`의 다음 요소인 `que[4]`에 24를 저장합니다. 이 처리의 복잡도는 O(1)이고 적은 비용으로 구현할 수 있습니다.

### 19 디큐

`que[0]`에 저장된 19를 꺼낸 다음 두 번쨰 이후의 요소를 맨 앞으로 옮깁니다.

이 처리의 복잡도는 O(n)이며 데이터를 꺼낼 때마다 이런 처리를 하게 되면 효율이 떨어집니다.

## 링 버퍼로 큐 만들기

이번에는 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현해 보겠습니다. 이를 위해 사용하는 자료구조가 링 버퍼입니다.

링 버퍼는 배열의 처음이 끝에 연결되어 있다고 보는 자료구조 입니다.

여기서 논리적으로 어떤 요소가 첫 번쨰 요소이고 어떤 요소가 마지막 요소인지 식별하기 위한 변수가 프론트(front)와 리어(rear)입니다.

> 프런트(front) : 맨 처음 요소의 인덱스
> 리어(rear) : 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정)

1. 7개의 데이터(35,56,24,68,95,73,19)가 차례대로 `que[7], que[8], ... que[11], que[0], que[1]`에 저장됩니다. 프런트 값은 7이고 리어 값은 2입니다.

1. 82를 인큐한 다음 상태입니다. `que[2]`(리어가 가리키고 있는 위치)에 82를 저장한 다음 리어 값을 1만큼 증가합니다.

1. 35를 디큐한 다음의 상태입니다. 프런트 요소(`que[front], que[7]`)의 값 35를 뺴고 프런트 값을 1만큼 증가합니다.

이렇게 큐를 구현하면 프런트와 리어 값을 업데이트 하며 인큐 와 디큐를 수행하기 때문에 앞에서 발생한 요소 이동 문제를 해결할 수 있습니다.

물론 처리의 복잡도는 O(1)입니다.

```java
class Main {
    private int max;
    private int front;
    private int rear;
    private int num;
    private int[] que;

    public class EmptyIntQueueException extends RuntimeException {
        public EmptyIntQueueException() {
        }
    }

    public class OverflowIntQueueException extends RuntimeException {
        public OverflowIntQueueException() {
        }
    }

    public Main(int capacity) {
        num = front = rear = 0;
        max= capacity;
        try {
            que = new int[max];
        } catch (OutOfMemoryError e) {
            max = 0;
        }
    }
}
```

### 큐 클래스 IntQueue

1. 큐로 사용할 배열(que)
   인큐하는 데이터를 저장하기 위한 큐 본체용 배열입니다.
1. 큐의 최대 용량(max)
   큐의 최대 용량을 저장하는 필드로, 이 값은 배열 que에 저장할 수 있는 최대 요소의 개수와 같습니다.
1. 프런트(front)
   인큐하는 데이터 가운데 첫번째 요소의 인덱스를 저장하는 필드입니다.
1. 리어(rear)
   인큐한 데이터 가운데 맨 나중에 넣은 요소의 하나 뒤의 인덱스를 저장하는 필드입니다.
1. 현재 데이터 수(num)
   큐에 쌓아 놓은 데이터 수를 나타내는 필드입니다. front와 rear의 값이 같은 경우 큐가 비어있는지, 가득 찼는지 구별할 수 없는 상황을 피하기 위해 이 변수가 필요합니다.
   큐가 비어 있을 때 num은 0이고, 가득 찼을 때는 num 과 max 값이 같습니다.

front와 rear의 값이 같음으로 큐의 상태가 비어 있는지, 아닌지 구분할 수 없는 경우에 대해 생각해 보겠습니다.

이렇게 num과 max가 없다면 front와 rear 값만으로는 두 상태를 구분할 수 없습니다.

### 생성자 IntQueue

생성자는 큐 본체용 배열을 생성하는 등의 준비 작업을 수행합니다. 생성 시 큐는 비어 있기 때문에 num, front, rear 값을 모두 0으로 합니다.

또 매개변수 capacity로 전달받은 큐의 용량을 필드 max에 복사하고, 요소수가 max인 배열 que의 본체를 생성합니다.

```java
public int enque(int x) throws OverflowIntQueueException {
    if (num >= max) {
        throw new OverflowIntQueueException();
    }
    que[rear++] = x;
    num++;
    if(rear == max) {
        rear = 0;
    }
    return x;
}
```

### 인큐 메서드 enque

큐에 데이터를 인큐하는 메서드입니다. 인큐에 성공하면 인큐한 값을 그대로 반환합니다.

그러나 큐가 가득차서 인큐할 수 없다면(num >= max가 성립하면) 예외 OverflowIntQueueException을 던집니다.

만약 인큐하기 전의 rear값이 11이면 enque 메서드를 수행한 다음에는 rear값이 12가 되면서 max(Initialize 메서드에서 초기화한 값 12)와 같아지는 문제가 발생합니다.

rear값을 1만큼 증가했을 떄 큐의 최대 용량의 값인 max와 같아질 경우 rear를 배열의 처음인 0으로 변경해야 합니다.

```java
public int deque() throws EmptyIntQueueException {
    if (num <= 0) {
        throw new EmptyIntQueueException();
    }
    int x = que[front++];
    num--;
    if (front == max) {
        front = 0;
    }
    return x;
}
```

### 디큐 메서드 deque

큐에서 데이터를 디큐하고 그 값을 반환하는 메서드입니다. 그러나 큐가 비어 있어 디큐할 수 없으면(num <= 0이 성립하면) 예외 EmptyIntQueueException을 던집니다.

`que[front](que[7])`에 저장한 값 35를 꺼내고 front 값을 1만큼 증가한 다음 num 값을 1만큼 감소합니다.

디큐하기 전의 front 값이 배열의 끝이라면 위의 과정을 거치고 난 후의 front 값은 max(12)가 되어 배열 마지막 요소의 인덱스를 초과합니다.

1만큼 증가한 front 값이 큐의 용량인 max와 같아지면 front 값을 배열의 처음인 0으로 변경해야 합니다.

```java
public int peek() throws EmptyIntQueueException {
    if (num <= 0) {
        throw new EmptyIntQueueException();
    }
    return que[front];
}

public int indexOf(int x) {
    for (int i = 0; i < num; i++) {
        int idx = (i + front) % max;
        if (que[idx] == x) {
            return idx;
        }
    }
    return -1;
}

public void clear() {
    num = front = rear = 0;
}

public int capacity() {
    return max;
}

public int size() {
    return num;
}

public boolean isEmpty() {
    return num <= 0;
}

public boolean isFull() {
    return num >= max;
}

public void dump() {
    if (num <= 0) {
        System.out.printIn("큐가 비어 있습니다.");
    } else {
        for (int i = 0; i < num; i++) {
            System.out.print(que[(i + front) % max] + " ");
        }
        System.out.println();
    }
}
```

### 피크 메서드 peek

맨 앞의 데이터(디큐에서 꺼낼 데이터)를 몰래 엿보는 메서드입니다. `que[front]`의 값을 조사만 하고 데이터를 꺼내지는 않으므로 front, rear, num의 값은 변화하지 않습니다.

큐가 비어 있으면 예외 EmptyIntQueueException을 던집니다.

### 검색 메서드 indexOf

큐의 배열에서 x와 같은 데이터가 저장되어 있는 위치를 알아내는 메서드입니다. 프런트에서 리어 쪽으로 선형 검색을 수행합니다.

스캔의 시작은 배열의 첫 요소가 아니라 큐의 첫 요소, 즉 프런트입니다. 그래서 스캔할때 주목하는 인덱스 idx의 계산이 (i + front) % max로 복잡합니다.

검색에 성공하면 찾은 요소의 인덱스를 반환하고 실패하면 -1을 반환합니다.

### 모든 데이터를 삭제하는 메서드 clear

현재 큐의 모든 데이터를 삭제하는 메서드입니다.

### 최대 용량을 확인하는 메서드 capacity

큐의 최대 용량을 반환하는 메서드입니다.

### 데이터 수를 확인하는 size

현재 큐의 데이터 수를 반환하는 메서드입니다.

### 큐가 비어 있는지 판단하는 메서드 IsEmpty

큐가 비어 있는지 판단하는 메서드입니다. 비어 있으면 true, 그렇지 않으면 false를 반환합니다.

### 큐가 가득 찼는지 판단하는 메서드 IsFull

큐가 가득 찼는지 판단하는 메서드입니다. 가득 찼으면 true, 그렇지 않으면 false를 반환합니다.

### 모든 데이터를 출력하는 메서드 dump

큐에 인큐된 모든 데이터를 프론트에서 리어 순으로 출력하는 메서드입니다. 큐가 비어 있으면 큐가 비어 있습니다. 라고 표시합니다.

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        IntQueue s = new IntQueue(64);

        while (true) {
            System.out.println("현재 데이터 수:" + s.size() + " / " + s.capacity());
            System.out.print("(1) 인큐 (2) 디큐 (3) 피크 (4) 덤프 (0) 종료: ");

            int menu = stdIn.nextInt();
            if (menu == 0) break;

            int x;
            switch (menu) {
                case 1:
                    System.out.print("데이터 : ");
                    x = stdIn.nextInt();
                    try {
                        s.enque(x);
                    } catch (IntStack.OverflowIntStackException e) {
                        System.out.println("큐가 가득 찼습니다.");
                    }
                    break;
                case 2:
                    try {
                        x = s.deque();
                        System.out.println("디큐한 데이터는 " + x + "입니다.");
                    } catch (IntStack.EmptyIntStackException e) {
                        System.out.println("큐가 비었습니다.");
                    }
                    break;
                case 3:
                    try {
                        x = s.peek();
                        System.out.println("피크한 데이터는 " + x + "입니다.");
                    } catch (IntStack.EmptyIntStackException e) {
                        System.out.println("큐가 비어 있습니다.");
                    }
                    break;
                case 4:
                    s.dump();
                    break;
            }
        }
    }
}
```

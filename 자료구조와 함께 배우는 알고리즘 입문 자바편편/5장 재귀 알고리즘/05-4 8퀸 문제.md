# 05-4 8퀸 문제

## 8퀸 문제란?

> 서로 공격하여 잡을 수 없도록 8개의 퀸을 8 x 8 체스판에 놓으세요

## 퀸 배치하기

퀸은 자신과 같은 열에 있는 다른 퀸을 공격할 수 있으므로 아래와 같은 규칙을 세울 수 있습니다.

> 각 열에 퀸을 1개만 배치합니다.

퀸은 자신과 같은 행에 있는 다른 퀸을 공격할 수 있기 떄문입니다.

> 각 행에 퀸을 1개만 배치합니다.

## 가지 뻗기

배열 pos는 퀸의 배치를 나타냅니다. i열에 놓인 퀸의 위치가 j행이면 `pos[i]`의 값을 j로 합니다.

예를 들어 `pos[0]`의 값이 0이면 0열의 퀸이 0행에 배치된 상태를 의미합니다.

이때 set 메서드는 `pos[i]`에 0부터 7까지의 값을 순서대로 대입하여 i열에 퀸을 1개만 배치하는 8가지 조합을 만드는 재귀 메서드입니다.

매개변수 i가 이 퀸을 배치할 열입니다.

```java
public class QueenB {
    static int[] pos = new int[8];

    static void print() {
        for (int i = 0; i < 8; i++) {
            System.out.printf("%2d",pos[i]);
        }
        System.out.println();
    }

    static void set(int i) {
        for (int j = 0; j < 8; j++) {
            pos[i] = j;
            if (i == 7) {
                print();
            } else {
                set(i + 1);
            }
        }
    }

    public static void main(String[] args) {
        set(0);
    }
}
```

문제를 세분하고 세분된 작은 문제의 풀이를 결합해 전체 문제를 풀이하는 기법을 분할 정복법이라고 합니다.

## 분기 한정법

가지 뻗기로 퀸을 배치하는 조합을 나열할 수는 있지만 8퀸 문제의 답을 얻을 수는 없습니다.

다음은 앞에서 분기를 한정하기 위해 정했던 규칙입니다.

> 각 행에 퀸을 1개만 배치합니다.

```java
public class QueenB {
    static int[] pos = new int[8];
    static boolean[] flag = new boolean[8];

    static void print() {
        for (int i = 0; i < 8; i++) {
            System.out.printf("%2d",pos[i]);
        }
        System.out.println();
    }

    static void set(int i) {
        for (int j = 0; j < 8; j++) {
            if(!flag[i]) {
                pos[i] = j;
                if (i == 7) {
                    print();
                } else {
                    flag[j] = true;
                    set(i + 1);
                    flag[j] = false;
                }
            }
        }
    }

    public static void main(String[] args) {
        set(0);
    }
}
```

flag는 같은 행에 중복하여 퀸이 배치되는 것을 방지하기 위한 표시입니다.

1. 0행에 퀸을 배치하는 방법입니다. `flag[0]`의 값이 true이므로 이 행에는 퀸을 이미 배치했음을 알 수 있습니다. 따라서 여기에는 배치하지 않습니다.
1. 1행에 퀸을 배치하는 방법입니다. `flag[1]`의 값이 false이므로 이 행에는 퀸을 아직 배치하지 않았습니다. 1행에 퀸을 배치합니다. 다시 말해 set메서드를 재귀 호출하여 다음열인 2번쨰에 퀸을 배치합니다.

또 재귀 호출한 set(i + 1) 메서드 실행이 끝나면 퀸이 j행에서 제거되었기 때문에 `flag[j]`에는 아직 배치하지 않았음을 나타내는 false를 대입합니다.
set메서드에서는 퀸을 배치하지 않은행(`flag[j]`의 값이 false인 행)에만 퀸을 배치합니다.

이처럼 필요하지 않은 분기를 없애 불필요한 조합을 줄이는 방법을 한정 조작이라고 하고, 가지 뻗기와 한정 조작을 조합하야 문제를 풀어가는 방법을 분기 한정법 이라고 합니다.

## 8퀸 문제를 푸는 프로그램

퀸은 대각선 방향으로도 이동할 수 있기 때문에 어떤 대각선에서 보더라도 퀸을 1개만 배치하는 한정 조작을 추가해야합니다.

```java
public class QueenB {
    static int[] pos = new int[8];
    static boolean[] flag_a = new boolean[8];
    static boolean[] flag_b = new boolean[15];
    static boolean[] flag_c = new boolean[15];

    static void print() {
        for (int i = 0; i < 8; i++) {
            System.out.printf("%2d",pos[i]);
        }
        System.out.println();
    }

    static void set(int i) {
        for (int j = 0; j < 8; j++) {
            if(flag_a[j] == false && flag_b[i + j] == false && flag_c[i - j + 7] == false) {
                pos[i] = j;
                if (i == 7) {
                    print();
                } else {
                    flag_a[j] = flag_b[i + j] = flag_c[i -j + 7] = true;
                    set(i + 1);
                    flag_a[j] = flag_b[i + j] = flag_c[i -j + 7] = false;
                }
            }
        }
    }

    public static void main(String[] args) {
        set(0);
    }
}
```

j행 i열에서 각각의 대각선 방향에 대해 퀸이 배치되었을때 체크하는 배열의 인덱스는 `flag_b[i + j]`와 `flag_c[i - j + 7]`입니다.

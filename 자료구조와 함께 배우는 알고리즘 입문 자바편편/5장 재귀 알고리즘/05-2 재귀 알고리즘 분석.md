# 05-2 재귀 알고리즘 분석

## 재귀 알고리즘의 분석

```java
class Recur {
    static void recur(int n) {
        if (n > 0) {
            recur(n - 1);
            System.out.println(n);
            recur(n - 2);
        }
    }
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("정수를 입력하세요 : ");
        int x = stdIn.nextInt();

        recur(x);
    }
}
```

recur 메서드는 factorial 메서드나 gcd 메서드와 달리 메서드 안에서 재귀 호출을 2회 실행합니다. 이처럼 재귀 호출을 여러 회 실행하는 메서드를 순수하게 재귀적이라 하며, 실제 동작은 매우 복잡합니다.

이런 복잡한 구조를 가진 재귀 메서드는 좀 더 전략적으로 분석해야 합니다. 여기서는 recur 메서드를 하향식과 상향식의 두 방법으로 분석합니다.

### 하향식 분석

매개변수 n으로 4를 전달하면 recur 메서드는 아래 과정을 순서대로 실행합니다.

1. recur(3)을 실행합니다.
1. 4를 출력합니다.
1. recur(2)를 실행합니다.

물론 4를 출력하느 것은 recur(3) 실행이 완료된 다음입니다. 따라서 recur(3)을 먼저 조사해야 합니다.

이처럼 가장 위쪽에 위치한 상자의 메서드 호출부터 시작해 계단식으로 자세히 조사하는 분석 기법을 하향식 분석이라고 합니다.

recur(1), recur(2)의 호출이 여러번 있습니다. 꼭대기(top)부터 분석하면 이렇게 같은 메서드의 호출이 여러 번 나올 수 있기 때문에 하향식 분석이 반드시 효율적이다 라고 말할 수는 없습니다.

### 상향식 분석

위쪽부터 분석하는 하향식 분석과는 대조적으로 아래쪽으로 쌓아올리며 분석하는 방법이 상향식 분석입니다.

recur 메서드는 n이 양수일때만 실행하므로 먼저 recur(1)을 생각해 보겠습니다.

1. recur(0)을 실행합니다.
1. 1을 출력합니다.
1. recur(-1)을 실행합니다.

여기서 recur(0)과 recur(-1)은 출력할 내용이 없습니다. 따라서 1만 출력합니다. 그럼 recur(2)에 대해 생각해 봅시다.

1. recur(1)을 실행합니다.
1. 2를 출력합니다.
1. recur(0)을 실행합니다.

recur(1)은 1을 출력하고 recur(0)은 출력할 내용이 없습니다. 전체 과정을 거치면 1과 2가 출력됩니다.

다음과 같은 과정을 거치면 recur(4)가 출력됩니다.

## 재귀 알고리즘의 비재귀적 표현

### 꼬리 재귀의 제거

메서드의 꼬리에서 재귀 호출하는 메서드 recur(n - 2)라는 말은 인자로 n - 2를 전달하여 recur 메서드를 호출한다는 의미입니다. 따라서 이 호출은 아래 처럼 바꿀 수 있습니다.

> n의 값을 n - 2로 업데이트하고 메서드의 시작 지점으로 돌아갑니다.

```java
static void recur(int n) {
    while(n > 0) {
        recur(n - 1);
        System.out.println(n);
        n = n - 2;
    }
}
```

### 재귀의 제거

꼬리 재귀와는 다르게 앞에서 호출한 재귀 메서드의 제거는 쉽지 않습니다. 왜냐하면 변수 n의 값을 출력하기 전에 recur(n - 1)을 먼저 수행해야 하기 떄문입니다.

예를 들어 n이 4인 경우 재귀 호출 recur(3)의 처리가 완료되지 않으면 n의 값인 4를 저장해야 합니다.

그래서 재귀 호출 recur(n - 1)을 아래처럼 바로 바꿀 수 없습니다.

> n의 값을 n - 1로 업데이트하고 메서드의 시작 지점으로 돌아갑니다.

왜냐하면 다음과 같은 처리를 미리 해야 하기 떄문입니다.

> 현재 n의 값을 잠시 저장합니다.

또 recur(n - 1)의 처리가 완료된 다음에 n의 값을 출력할 때는 다음 과정을 따르게 됩니다.

> 저장했던 n의 다시 꺼내 그 값을 출력합니다.

이런 재귀 호출을 제거하기 위해서는 변수 n의 값을 잠시 저장해야 한다는 사살을 알겠습니다. 이떄 이런 문제를 잘 해결할 수 있는 데이터 구조가 바로 앞 장에서 살펴본 스택입니다.

```java
static void recur(int n) {
    IntStack s = new IntStack(n);

    while (true) {
        if (n > 0) {
            s.push(n);
            n = n - 1;
            continue;
        }
        if (s.isEmpty() != true) {
            n = s.pop();
            System.out.println(n);
            n = n - 2;
            continue;
        }
        break;
    }
}
```

recur(4)를 호출한 다음의 과정을 살펴보겠습니다. 매개변수로 전달받은 값 4는 0보다 크므로 맨 앞의 if문에 의해 다음과 같은 과정이 진행됩니다.

1. n 값 4를 스택에 푸시합니다.
1. n 값을 하나 줄여 3으로 만듭니다.
1. continue문에 의해 while문의 처음으로 돌아갑니다.

n 값 3은 0보다 크므로 첫 번째 if문이 실행됩니다. 그 결과 위의 과정이 반복됩니다. 그러면 b -> c -> d의 순서대로 실행되면서 스택에 4,3,2,1이 쌓이게 됩니다.

마지막으로 스택에 1을 쌓은 다음 0이 되고 while문의 처음으로 돌아갑니다.

그러면 n 값이 되므로 첫번쨰 if문은 그냥 지나가고 다음의 if문에 의해 다음과 같은 과정이 진행됩니다.

1. 스택에서 팝한 값 1을 n에 꺼내 놓습니다.
1. n 값 1을 출력합니다.
1. n 값 2 줄여 -1로 만듭니다.
1. continue문에 의해 while문의 처음으로 돌아갑니다.

n 값이 -1이므로 다시 뒤쪽의 if문이 실행되고 스택에서 2가 팝됩니다.
